"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryBuilder = void 0;
const core_1 = require("@mikro-orm/core");
const enums_1 = require("./enums");
const QueryBuilderHelper_1 = require("./QueryBuilderHelper");
const CriteriaNodeFactory_1 = require("./CriteriaNodeFactory");
/**
 * SQL query builder with fluent interface.
 *
 * ```ts
 * const qb = orm.em.createQueryBuilder(Publisher);
 * qb.select('*')
 *   .where({
 *     name: 'test 123',
 *     type: PublisherType.GLOBAL,
 *   })
 *   .orderBy({
 *     name: QueryOrder.DESC,
 *     type: QueryOrder.ASC,
 *   })
 *   .limit(2, 1);
 *
 * const publisher = await qb.getSingleResult();
 * ```
 */
class QueryBuilder {
    /**
     * @internal
     */
    constructor(entityName, metadata, driver, context, alias, connectionType, em) {
        this.entityName = entityName;
        this.metadata = metadata;
        this.driver = driver;
        this.context = context;
        this.connectionType = connectionType;
        this.em = em;
        /** @internal */
        this._populate = [];
        /** @internal */
        this._populateMap = {};
        this.aliasCounter = 0;
        this.flags = new Set([core_1.QueryFlag.CONVERT_CUSTOM_TYPES, core_1.QueryFlag.DISABLE_PAGINATE]);
        this.finalized = false;
        this._joins = {};
        this._aliasMap = {};
        this._cond = {};
        this._orderBy = [];
        this._groupBy = [];
        this._having = {};
        this._joinedProps = new Map();
        this.subQueries = {};
        this.platform = this.driver.getPlatform();
        this.knex = this.driver.getConnection(this.connectionType).getKnex();
        if (alias) {
            this.aliasCounter++;
        }
        this.alias = alias ?? this.getNextAlias(this.entityName);
        this._aliasMap[this.alias] = this.entityName;
        this.helper = new QueryBuilderHelper_1.QueryBuilderHelper(this.entityName, this.alias, this._aliasMap, this.subQueries, this.knex, this.driver);
    }
    select(fields, distinct = false) {
        this._fields = core_1.Utils.asArray(fields);
        if (distinct) {
            this.flags.add(core_1.QueryFlag.DISTINCT);
        }
        return this.init(enums_1.QueryType.SELECT);
    }
    addSelect(fields) {
        if (this.type && this.type !== enums_1.QueryType.SELECT) {
            return this;
        }
        return this.select([...core_1.Utils.asArray(this._fields), ...core_1.Utils.asArray(fields)]);
    }
    insert(data) {
        return this.init(enums_1.QueryType.INSERT, data);
    }
    update(data) {
        return this.init(enums_1.QueryType.UPDATE, data);
    }
    delete(cond) {
        return this.init(enums_1.QueryType.DELETE, undefined, cond);
    }
    truncate() {
        return this.init(enums_1.QueryType.TRUNCATE);
    }
    count(field, distinct = false) {
        this._fields = [...(field ? core_1.Utils.asArray(field) : this.metadata.find(this.entityName).primaryKeys)];
        if (distinct) {
            this.flags.add(core_1.QueryFlag.DISTINCT);
        }
        return this.init(enums_1.QueryType.COUNT);
    }
    join(field, alias, cond = {}, type = 'innerJoin', path) {
        this.joinReference(field, alias, cond, type, path);
        return this;
    }
    leftJoin(field, alias, cond = {}) {
        return this.join(field, alias, cond, 'leftJoin');
    }
    joinAndSelect(field, alias, cond = {}, type = 'innerJoin', path) {
        if (!this.type) {
            this.select('*');
        }
        const prop = this.joinReference(field, alias, cond, type, path);
        this.addSelect(this.getFieldsForJoinedLoad(prop, alias));
        const [fromAlias] = this.helper.splitField(field);
        const populate = this._joinedProps.get(fromAlias);
        const item = { field: prop.name, strategy: core_1.LoadStrategy.JOINED, children: [] };
        if (populate) {
            populate.children.push(item);
        }
        else { // root entity
            this._populate.push(item);
        }
        this._joinedProps.set(alias, item);
        return this;
    }
    leftJoinAndSelect(field, alias, cond = {}) {
        return this.joinAndSelect(field, alias, cond, 'leftJoin');
    }
    getFieldsForJoinedLoad(prop, alias) {
        const fields = [];
        prop.targetMeta.props
            .filter(prop => this.platform.shouldHaveColumn(prop, this._populate))
            .forEach(prop => fields.push(...this.driver.mapPropToFieldNames(this, prop, alias)));
        return fields;
    }
    withSubQuery(subQuery, alias) {
        this.subQueries[alias] = subQuery.toString();
        return this;
    }
    where(cond, params, operator) {
        if (core_1.Utils.isString(cond)) {
            cond = { [`(${cond})`]: core_1.Utils.asArray(params) };
            operator = operator || '$and';
        }
        else {
            cond = core_1.QueryHelper.processWhere(cond, this.entityName, this.metadata, this.platform, this.flags.has(core_1.QueryFlag.CONVERT_CUSTOM_TYPES));
        }
        const op = operator || params;
        const topLevel = !op || !core_1.Utils.hasObjectKeys(this._cond);
        const criteriaNode = CriteriaNodeFactory_1.CriteriaNodeFactory.createNode(this.metadata, this.entityName, cond);
        if ([enums_1.QueryType.UPDATE, enums_1.QueryType.DELETE].includes(this.type) && criteriaNode.willAutoJoin(this)) {
            // use sub-query to support joining
            this.setFlag(this.type === enums_1.QueryType.UPDATE ? core_1.QueryFlag.UPDATE_SUB_QUERY : core_1.QueryFlag.DELETE_SUB_QUERY);
            this.select(this.metadata.find(this.entityName).primaryKeys, true);
        }
        if (topLevel) {
            this._cond = criteriaNode.process(this);
        }
        else if (Array.isArray(this._cond[op])) {
            this._cond[op].push(criteriaNode.process(this));
        }
        else {
            const cond1 = [this._cond, criteriaNode.process(this)];
            this._cond = { [op]: cond1 };
        }
        if (this._onConflict) {
            this._onConflict[this._onConflict.length - 1].where = this._cond;
            this._cond = {};
        }
        return this;
    }
    andWhere(cond, params) {
        return this.where(cond, params, '$and');
    }
    orWhere(cond, params) {
        return this.where(cond, params, '$or');
    }
    orderBy(orderBy) {
        this._orderBy = [];
        core_1.Utils.asArray(orderBy).forEach(o => {
            const processed = core_1.QueryHelper.processWhere(o, this.entityName, this.metadata, this.platform, false);
            this._orderBy.push(CriteriaNodeFactory_1.CriteriaNodeFactory.createNode(this.metadata, this.entityName, processed).process(this));
        });
        return this;
    }
    groupBy(fields) {
        this._groupBy = core_1.Utils.asArray(fields);
        return this;
    }
    having(cond = {}, params) {
        if (core_1.Utils.isString(cond)) {
            cond = { [`(${cond})`]: core_1.Utils.asArray(params) };
        }
        this._having = CriteriaNodeFactory_1.CriteriaNodeFactory.createNode(this.metadata, this.entityName, cond).process(this);
        return this;
    }
    onConflict(fields = []) {
        this._onConflict = this._onConflict || [];
        this._onConflict.push({ fields: core_1.Utils.asArray(fields) });
        return this;
    }
    ignore() {
        if (!this._onConflict) {
            throw new Error('You need to call `qb.onConflict()` first to use `qb.ignore()`');
        }
        this._onConflict[this._onConflict.length - 1].ignore = true;
        return this;
    }
    merge(data) {
        if (!this._onConflict) {
            throw new Error('You need to call `qb.onConflict()` first to use `qb.merge()`');
        }
        this._onConflict[this._onConflict.length - 1].merge = data;
        return this;
    }
    /**
     * @internal
     */
    populate(populate) {
        this._populate = populate;
        return this;
    }
    /**
     * @internal
     */
    ref(field) {
        return this.knex.ref(field);
    }
    raw(sql, bindings = []) {
        const raw = this.knex.raw(sql, bindings);
        raw.__raw = true; // tag it as there is now way to check via `instanceof`
        return raw;
    }
    limit(limit, offset = 0) {
        this._limit = limit;
        if (offset) {
            this.offset(offset);
        }
        return this;
    }
    offset(offset) {
        this._offset = offset;
        return this;
    }
    withSchema(schema) {
        this._schema = schema;
        return this;
    }
    setLockMode(mode, tables) {
        if (mode != null && mode !== core_1.LockMode.OPTIMISTIC && !this.context) {
            throw core_1.ValidationError.transactionRequired();
        }
        this.lockMode = mode;
        this.lockTables = tables;
        return this;
    }
    setFlushMode(flushMode) {
        this.flushMode = flushMode;
        return this;
    }
    setFlag(flag) {
        this.flags.add(flag);
        return this;
    }
    unsetFlag(flag) {
        this.flags.delete(flag);
        return this;
    }
    cache(config = true) {
        this._cache = config;
        return this;
    }
    /**
     * Adds index hint to the FROM clause.
     */
    indexHint(sql) {
        this._indexHint = sql;
        return this;
    }
    getKnexQuery() {
        this.finalize();
        const qb = this.getQueryBase();
        core_1.Utils.runIfNotEmpty(() => this.helper.appendQueryCondition(this.type, this._cond, qb), this._cond && !this._onConflict);
        core_1.Utils.runIfNotEmpty(() => qb.groupBy(this.prepareFields(this._groupBy, 'groupBy')), this._groupBy);
        core_1.Utils.runIfNotEmpty(() => this.helper.appendQueryCondition(this.type, this._having, qb, undefined, 'having'), this._having);
        core_1.Utils.runIfNotEmpty(() => {
            const queryOrder = this.helper.getQueryOrder(this.type, this._orderBy, this._populateMap);
            if (queryOrder) {
                return qb.orderByRaw(queryOrder);
            }
        }, this._orderBy);
        core_1.Utils.runIfNotEmpty(() => qb.limit(this._limit), this._limit != null);
        core_1.Utils.runIfNotEmpty(() => qb.offset(this._offset), this._offset);
        core_1.Utils.runIfNotEmpty(() => this.helper.appendOnConflictClause(this.type, this._onConflict, qb), this._onConflict);
        if (this.type === enums_1.QueryType.TRUNCATE && this.platform.usesCascadeStatement()) {
            return this.knex.raw(qb.toSQL().toNative().sql + ' cascade');
        }
        if (this.lockMode) {
            this.helper.getLockSQL(qb, this.lockMode, this.lockTables);
        }
        this.helper.finalize(this.type, qb, this.metadata.find(this.entityName));
        return qb;
    }
    /**
     * Returns the query with parameters as wildcards.
     */
    getQuery() {
        return this.getKnexQuery().toSQL().toNative().sql;
    }
    /**
     * Returns the list of all parameters for this query.
     */
    getParams() {
        return this.getKnexQuery().toSQL().toNative().bindings;
    }
    /**
     * Returns raw interpolated query string with all the parameters inlined.
     */
    getFormattedQuery() {
        const query = this.getKnexQuery().toSQL();
        return this.platform.formatQuery(query.sql, query.bindings);
    }
    getAliasForJoinPath(path) {
        if (!path || path === this.entityName) {
            return this.alias;
        }
        const join = Object.values(this._joins).find(j => j.path === path);
        if (path.endsWith('[pivot]') && join) {
            return join.alias;
        }
        return join?.inverseAlias || join?.alias;
    }
    getNextAlias(entityName = 'e') {
        return this.driver.config.getNamingStrategy().aliasName(entityName, this.aliasCounter++);
    }
    /**
     * Executes this QB and returns the raw results, mapped to the property names (unless disabled via last parameter).
     * Use `method` to specify what kind of result you want to get (array/single/meta).
     */
    async execute(method = 'all', mapResults = true) {
        if (!this.connectionType && method !== 'run' && [enums_1.QueryType.INSERT, enums_1.QueryType.UPDATE, enums_1.QueryType.DELETE, enums_1.QueryType.TRUNCATE].includes(this.type)) {
            this.connectionType = 'write';
        }
        const query = this.getKnexQuery().toSQL();
        const cached = await this.em?.tryCache(this.entityName, this._cache, ['qb.execute', query.sql, query.bindings, method]);
        if (cached?.data) {
            return cached.data;
        }
        const type = this.connectionType || (method === 'run' ? 'write' : 'read');
        const res = await this.driver.getConnection(type).execute(query.sql, query.bindings, method, this.context);
        const meta = this.metadata.find(this.entityName);
        if (!mapResults || !meta) {
            await this.em?.storeCache(this._cache, cached, res);
            return res;
        }
        if (method === 'all' && Array.isArray(res)) {
            const map = {};
            const mapped = res.map(r => this.driver.mapResult(r, meta, this._populate, this, map));
            await this.em?.storeCache(this._cache, cached, mapped);
            return mapped;
        }
        const mapped = this.driver.mapResult(res, meta, this._populate, this);
        await this.em?.storeCache(this._cache, cached, mapped);
        return mapped;
    }
    /**
     * Alias for `qb.getResultList()`
     */
    async getResult() {
        return this.getResultList();
    }
    /**
     * Executes the query, returning array of results
     */
    async getResultList() {
        await this.em.tryFlush(this.entityName, { flushMode: this.flushMode });
        let res = await this.execute('all', true);
        if (this._joinedProps.size > 0) {
            res = this.driver.mergeJoinedResult(res, this.metadata.find(this.entityName));
        }
        return res.map(r => this.em.map(this.entityName, r, { schema: this._schema }));
    }
    /**
     * Executes the query, returning the first result or null
     */
    async getSingleResult() {
        const res = await this.getResultList();
        return res[0] || null;
    }
    /**
     * Executes count query (without offset and limit), returning total count of results
     */
    async getCount(field, distinct = false) {
        const qb = this.clone();
        qb.count(field, distinct).limit(undefined).offset(undefined).orderBy([]);
        const res = await qb.execute('get', false);
        return res ? +res.count : 0;
    }
    /**
     * Provides promise-like interface so we can await the QB instance.
     */
    then(onfulfilled, onrejected) {
        return this.getInnerPromise().then(onfulfilled, onrejected);
    }
    getInnerPromise() {
        if (!this.innerPromise) {
            this.innerPromise = (async () => {
                switch (this.type) {
                    case enums_1.QueryType.INSERT:
                    case enums_1.QueryType.UPDATE:
                    case enums_1.QueryType.DELETE:
                    case enums_1.QueryType.TRUNCATE:
                        return this.execute('run');
                    case enums_1.QueryType.SELECT:
                        return this.getResultList();
                    case enums_1.QueryType.COUNT:
                        return this.getCount();
                }
            })();
        }
        return this.innerPromise;
    }
    /**
     * Returns knex instance with sub-query aliased with given alias.
     * You can provide `EntityName.propName` as alias, then the field name will be used based on the metadata
     */
    as(alias) {
        const qb = this.getKnexQuery();
        if (alias.includes('.')) {
            const [a, f] = alias.split('.');
            const meta = this.metadata.find(a);
            /* istanbul ignore next */
            alias = meta?.properties[f]?.fieldNames[0] ?? alias;
        }
        return qb.as(alias);
    }
    clone() {
        const qb = new QueryBuilder(this.entityName, this.metadata, this.driver, this.context, this.alias, this.connectionType, this.em);
        Object.assign(qb, this);
        // clone array/object properties
        const properties = [
            'flags', '_populate', '_populateMap', '_joins', '_joinedProps', '_aliasMap', '_cond', '_data', '_orderBy',
            '_schema', '_indexHint', '_cache', 'subQueries', 'lockMode', 'lockTables',
        ];
        properties.forEach(prop => qb[prop] = core_1.Utils.copy(this[prop]));
        /* istanbul ignore else */
        if (this._fields) {
            qb._fields = [...this._fields];
        }
        qb.finalized = false;
        return qb;
    }
    getKnex() {
        const tableName = this.helper.getTableName(this.entityName) + (this.finalized && this.helper.isTableNameAliasRequired(this.type) ? ` as ${this.alias}` : '');
        const qb = this.knex(tableName);
        if (this._schema) {
            qb.withSchema(this._schema);
        }
        if (this.context) {
            qb.transacting(this.context);
        }
        return qb;
    }
    joinReference(field, alias, cond, type, path) {
        const [fromAlias, fromField] = this.helper.splitField(field);
        const entityName = this._aliasMap[fromAlias];
        const meta = this.metadata.get(entityName);
        const prop = meta.properties[fromField];
        if (!prop) {
            throw new Error(`Trying to join ${field}, but ${fromField} is not a defined relation on ${meta.className}`);
        }
        this._aliasMap[alias] = prop.type;
        cond = core_1.QueryHelper.processWhere(cond, this.entityName, this.metadata, this.platform);
        let aliasedName = `${fromAlias}.${prop.name}#${alias}`;
        path ?? (path = `${(Object.values(this._joins).find(j => j.alias === fromAlias)?.path ?? entityName)}.${prop.name}`);
        if (prop.reference === core_1.ReferenceType.ONE_TO_MANY) {
            this._joins[aliasedName] = this.helper.joinOneToReference(prop, fromAlias, alias, type, cond);
        }
        else if (prop.reference === core_1.ReferenceType.MANY_TO_MANY) {
            let pivotAlias = alias;
            if (type !== 'pivotJoin') {
                const oldPivotAlias = this.getAliasForJoinPath(path + '[pivot]');
                pivotAlias = oldPivotAlias ?? this.getNextAlias(prop.pivotTable);
                aliasedName = `${fromAlias}.${prop.name}#${pivotAlias}`;
            }
            const joins = this.helper.joinManyToManyReference(prop, fromAlias, alias, pivotAlias, type, cond, path);
            Object.assign(this._joins, joins);
            this._aliasMap[pivotAlias] = prop.pivotTable;
        }
        else if (prop.reference === core_1.ReferenceType.ONE_TO_ONE) {
            this._joins[aliasedName] = this.helper.joinOneToReference(prop, fromAlias, alias, type, cond);
        }
        else { // MANY_TO_ONE
            this._joins[aliasedName] = this.helper.joinManyToOneReference(prop, fromAlias, alias, type, cond);
        }
        if (!this._joins[aliasedName].path && path) {
            this._joins[aliasedName].path = path;
        }
        return prop;
    }
    prepareFields(fields, type = 'where') {
        const ret = [];
        fields.forEach(field => {
            if (!core_1.Utils.isString(field)) {
                return ret.push(field);
            }
            const join = Object.keys(this._joins).find(k => field === k.substring(0, k.indexOf('#')));
            if (join && type === 'where') {
                return ret.push(...this.helper.mapJoinColumns(this.type, this._joins[join]));
            }
            const [a, f] = this.helper.splitField(field);
            const prop = this.helper.getProperty(f, a);
            if (prop && [core_1.ReferenceType.ONE_TO_MANY, core_1.ReferenceType.MANY_TO_MANY].includes(prop.reference)) {
                return;
            }
            ret.push(this.helper.mapper(field, this.type));
        });
        const meta = this.metadata.find(this.entityName);
        /* istanbul ignore next */
        const requiresSQLConversion = meta?.props.filter(p => p.customType?.convertToJSValueSQL) ?? [];
        if (this.flags.has(core_1.QueryFlag.CONVERT_CUSTOM_TYPES) && (fields.includes('*') || fields.includes(`${this.alias}.*`)) && requiresSQLConversion.length > 0) {
            requiresSQLConversion.forEach(p => ret.push(this.helper.mapper(p.name, this.type)));
        }
        Object.keys(this._populateMap).forEach(f => {
            if (!fields.includes(f.replace(/#\w+$/, '')) && type === 'where') {
                ret.push(...this.helper.mapJoinColumns(this.type, this._joins[f]));
            }
            if (this._joins[f].prop.reference !== core_1.ReferenceType.ONE_TO_ONE && this._joins[f].inverseJoinColumns) {
                this._joins[f].inverseJoinColumns.forEach(inverseJoinColumn => {
                    core_1.Utils.renameKey(this._cond, inverseJoinColumn, `${this._joins[f].alias}.${inverseJoinColumn}`);
                });
            }
        });
        return ret;
    }
    init(type, data, cond) {
        this.type = type;
        this._aliasMap[this.alias] = this.entityName;
        if ([enums_1.QueryType.UPDATE, enums_1.QueryType.DELETE].includes(type) && core_1.Utils.hasObjectKeys(this._cond)) {
            throw new Error(`You are trying to call \`qb.where().${type.toLowerCase()}()\`. Calling \`qb.${type.toLowerCase()}()\` before \`qb.where()\` is required.`);
        }
        if (!this.helper.isTableNameAliasRequired(type)) {
            delete this._fields;
        }
        if (data) {
            this._data = this.helper.processData(data, this.flags.has(core_1.QueryFlag.CONVERT_CUSTOM_TYPES));
        }
        if (cond) {
            this.where(cond);
        }
        return this;
    }
    getQueryBase() {
        const qb = this.getKnex();
        const meta = this.metadata.find(this.entityName);
        const metaSchema = meta?.schema && meta.schema !== '*' ? meta.schema : undefined;
        const schema = this._schema ?? metaSchema ?? this.em?.config.get('schema');
        if (schema) {
            qb.withSchema(schema);
        }
        if (this._indexHint) {
            const alias = this.helper.isTableNameAliasRequired(this.type) ? ` as ${this.platform.quoteIdentifier(this.alias)}` : '';
            const schemaQuoted = schema ? this.platform.quoteIdentifier(schema) + '.' : '';
            const tableName = schemaQuoted + this.platform.quoteIdentifier(this.helper.getTableName(this.entityName)) + alias;
            qb.from(this.knex.raw(`${tableName} ${this._indexHint}`));
        }
        switch (this.type) {
            case enums_1.QueryType.SELECT:
                qb.select(this.prepareFields(this._fields));
                if (this.flags.has(core_1.QueryFlag.DISTINCT)) {
                    qb.distinct();
                }
                this.helper.processJoins(qb, this._joins, schema);
                break;
            case enums_1.QueryType.COUNT: {
                const m = this.flags.has(core_1.QueryFlag.DISTINCT) ? 'countDistinct' : 'count';
                qb[m]({ count: this._fields.map(f => this.helper.mapper(f, this.type)) });
                this.helper.processJoins(qb, this._joins, schema);
                break;
            }
            case enums_1.QueryType.INSERT:
                qb.insert(this._data);
                break;
            case enums_1.QueryType.UPDATE:
                qb.update(this._data);
                this.helper.updateVersionProperty(qb, this._data);
                break;
            case enums_1.QueryType.DELETE:
                qb.delete();
                break;
            case enums_1.QueryType.TRUNCATE:
                qb.truncate();
                break;
        }
        return qb;
    }
    finalize() {
        if (this.finalized) {
            return;
        }
        if (!this.type) {
            this.select('*');
        }
        const meta = this.metadata.find(this.entityName);
        if (meta && this.flags.has(core_1.QueryFlag.AUTO_JOIN_ONE_TO_ONE_OWNER)) {
            const relationsToPopulate = this._populate.map(({ field }) => field);
            meta.relations
                .filter(prop => prop.reference === core_1.ReferenceType.ONE_TO_ONE && !prop.owner && !relationsToPopulate.includes(prop.name))
                .map(prop => ({ field: prop.name }))
                .forEach(item => this._populate.push(item));
        }
        this._populate.forEach(({ field }) => {
            const [fromAlias, fromField] = this.helper.splitField(field);
            const aliasedField = `${fromAlias}.${fromField}`;
            const join = Object.keys(this._joins).find(k => `${aliasedField}#${this._joins[k].alias}` === k);
            if (join && this._joins[join] && this.helper.isOneToOneInverse(fromField)) {
                return this._populateMap[join] = this._joins[join].alias;
            }
            if (this.metadata.find(field)?.pivotTable) { // pivot table entity
                this.autoJoinPivotTable(field);
            }
            else if (meta && this.helper.isOneToOneInverse(fromField)) {
                const prop = meta.properties[fromField];
                const alias = this.getNextAlias(prop.pivotTable ?? prop.type);
                const aliasedName = `${fromAlias}.${prop.name}#${alias}`;
                this._joins[aliasedName] = this.helper.joinOneToReference(prop, this.alias, alias, 'leftJoin');
                this._populateMap[aliasedName] = this._joins[aliasedName].alias;
            }
        });
        if (meta && (this._fields?.includes('*') || this._fields?.includes(`${this.alias}.*`))) {
            meta.props
                .filter(prop => prop.formula && (!prop.lazy || this.flags.has(core_1.QueryFlag.INCLUDE_LAZY_FORMULAS)))
                .map(prop => {
                const alias = this.knex.ref(this.alias).toString();
                const aliased = this.knex.ref(prop.fieldNames[0]).toString();
                return `${prop.formula(alias)} as ${aliased}`;
            })
                .filter(field => !this._fields.includes(field))
                .forEach(field => this.addSelect(field));
        }
        core_1.QueryHelper.processObjectParams(this._data);
        core_1.QueryHelper.processObjectParams(this._cond);
        core_1.QueryHelper.processObjectParams(this._having);
        this.finalized = true;
        // automatically enable paginate flag when we detect to-many joins
        if (this.flags.has(core_1.QueryFlag.DISABLE_PAGINATE) && this.hasToManyJoins()) {
            this.flags.add(core_1.QueryFlag.PAGINATE);
        }
        if (meta && this.flags.has(core_1.QueryFlag.PAGINATE) && (this._limit > 0 || this._offset > 0)) {
            this.wrapPaginateSubQuery(meta);
        }
        if (meta && (this.flags.has(core_1.QueryFlag.UPDATE_SUB_QUERY) || this.flags.has(core_1.QueryFlag.DELETE_SUB_QUERY))) {
            this.wrapModifySubQuery(meta);
        }
    }
    hasToManyJoins() {
        return this._joinedProps.size > 0 && Object.values(this._joins).some(join => {
            return [core_1.ReferenceType.ONE_TO_MANY, core_1.ReferenceType.MANY_TO_MANY].includes(join.prop.reference);
        });
    }
    wrapPaginateSubQuery(meta) {
        const pks = this.prepareFields(meta.primaryKeys, 'sub-query');
        const subQuery = this.clone().select(pks).groupBy(pks).limit(this._limit);
        if (this._offset) {
            subQuery.offset(this._offset);
        }
        if (this._orderBy.length > 0) {
            const orderBy = [];
            for (const orderMap of this._orderBy) {
                for (const [field, direction] of Object.entries(orderMap)) {
                    orderBy.push({
                        [`min(${this.ref(field)})`]: direction,
                    });
                }
            }
            subQuery.orderBy(orderBy);
        }
        subQuery.finalized = true;
        const knexQuery = subQuery.as(this.alias).clearSelect().select(pks);
        // multiple sub-queries are needed to get around mysql limitations with order by + limit + where in + group by (o.O)
        // https://stackoverflow.com/questions/17892762/mysql-this-version-of-mysql-doesnt-yet-support-limit-in-all-any-some-subqu
        const subSubQuery = this.getKnex().select(pks).from(knexQuery);
        this._limit = undefined;
        this._offset = undefined;
        this.select(this._fields).where({ [core_1.Utils.getPrimaryKeyHash(meta.primaryKeys)]: { $in: subSubQuery } });
    }
    wrapModifySubQuery(meta) {
        const subQuery = this.clone();
        subQuery.finalized = true;
        // wrap one more time to get around MySQL limitations
        // https://stackoverflow.com/questions/45494/mysql-error-1093-cant-specify-target-table-for-update-in-from-clause
        const subSubQuery = this.getKnex().select(this.prepareFields(meta.primaryKeys)).from(subQuery.as(this.alias));
        const method = this.flags.has(core_1.QueryFlag.UPDATE_SUB_QUERY) ? 'update' : 'delete';
        this._cond = {}; // otherwise we would trigger validation error
        this[method](this._data).where({
            [core_1.Utils.getPrimaryKeyHash(meta.primaryKeys)]: { $in: subSubQuery },
        });
    }
    autoJoinPivotTable(field) {
        const pivotMeta = this.metadata.find(field);
        const owner = pivotMeta.props.find(prop => prop.reference === core_1.ReferenceType.MANY_TO_ONE && prop.owner);
        const inverse = pivotMeta.props.find(prop => prop.reference === core_1.ReferenceType.MANY_TO_ONE && !prop.owner);
        const prop = this._cond[pivotMeta.name + '.' + owner.name] || this._orderBy[pivotMeta.name + '.' + owner.name] ? inverse : owner;
        const pivotAlias = this.getNextAlias(pivotMeta.name);
        this._joins[field] = this.helper.joinPivotTable(field, prop, this.alias, pivotAlias, 'leftJoin');
        core_1.Utils.renameKey(this._cond, `${field}.${owner.name}`, core_1.Utils.getPrimaryKeyHash(owner.fieldNames.map(fieldName => `${pivotAlias}.${fieldName}`)));
        core_1.Utils.renameKey(this._cond, `${field}.${inverse.name}`, core_1.Utils.getPrimaryKeyHash(inverse.fieldNames.map(fieldName => `${pivotAlias}.${fieldName}`)));
        this._populateMap[field] = this._joins[field].alias;
    }
}
exports.QueryBuilder = QueryBuilder;
