/// <reference types="node" />
import type { Transaction } from './connections';
import type { Cascade, EventType, LoadStrategy, LockMode, QueryOrderMap } from './enums';
import { ReferenceType } from './enums';
import type { AssignOptions, Collection, EntityFactory, EntityIdentifier, EntityRepository, IdentifiedReference, Reference, SerializationContext } from './entity';
import type { EntitySchema, MetadataStorage } from './metadata';
import type { Type } from './types';
import type { Platform } from './platforms';
import type { Configuration } from './utils';
import type { EntityManager } from './EntityManager';
export declare type Constructor<T = unknown> = new (...args: any[]) => T;
export declare type Dictionary<T = any> = {
    [k: string]: T;
};
export declare type ExcludeFunctions<T, K extends keyof T> = T[K] extends Function ? never : (K extends symbol ? never : K);
export declare type Cast<T, R> = T extends R ? T : R;
export declare type IsUnknown<T> = T extends unknown ? unknown extends T ? true : never : never;
export declare type DeepPartial<T> = T & {
    [P in keyof T]?: T[P] extends (infer U)[] ? DeepPartial<U>[] : T[P] extends Readonly<infer U>[] ? Readonly<DeepPartial<U>>[] : DeepPartial<T[P]>;
};
export declare const EntityRepositoryType: unique symbol;
export declare const PrimaryKeyType: unique symbol;
export declare const PrimaryKeyProp: unique symbol;
export declare const OptionalProps: unique symbol;
declare type ReadonlyPrimary<T> = T extends any[] ? Readonly<T> : T;
export declare type Primary<T> = T extends {
    [PrimaryKeyType]?: infer PK;
} ? ReadonlyPrimary<PK> : T extends {
    _id: infer PK;
} ? ReadonlyPrimary<PK> | string : T extends {
    uuid: infer PK;
} ? ReadonlyPrimary<PK> : T extends {
    id: infer PK;
} ? ReadonlyPrimary<PK> : never;
export declare type PrimaryProperty<T> = T extends {
    [PrimaryKeyProp]?: infer PK;
} ? PK : T extends {
    _id: any;
} ? '_id' | string : T extends {
    uuid: any;
} ? 'uuid' : T extends {
    id: any;
} ? 'id' : never;
export declare type IPrimaryKeyValue = number | string | bigint | Date | {
    toHexString(): string;
};
export declare type IPrimaryKey<T extends IPrimaryKeyValue = IPrimaryKeyValue> = T;
export declare type Scalar = boolean | number | string | bigint | symbol | Date | RegExp | Buffer | {
    toHexString(): string;
};
export declare type ExpandScalar<T> = null | (T extends string ? string | RegExp : T extends Date ? Date | string : T);
export declare type OperatorMap<T> = {
    $and?: Query<T>[];
    $or?: Query<T>[];
    $eq?: ExpandScalar<T>;
    $ne?: ExpandScalar<T>;
    $in?: ExpandScalar<T>[];
    $nin?: ExpandScalar<T>[];
    $not?: Query<T>;
    $gt?: ExpandScalar<T>;
    $gte?: ExpandScalar<T>;
    $lt?: ExpandScalar<T>;
    $lte?: ExpandScalar<T>;
    $like?: string;
    $re?: string;
    $ilike?: string;
    $overlap?: string[];
    $contains?: string[];
    $contained?: string[];
};
export declare type FilterValue2<T> = T | ExpandScalar<T> | Primary<T>;
export declare type FilterValue<T> = OperatorMap<FilterValue2<T>> | FilterValue2<T> | FilterValue2<T>[] | null;
declare type ExpandObject<T> = T extends object ? T extends Scalar ? never : {
    [K in keyof T as ExcludeFunctions<T, K>]?: Query<ExpandProperty<T[K]>> | FilterValue<ExpandProperty<T[K]>> | null;
} : never;
export declare type Query<T> = T extends object ? T extends Scalar ? never : FilterQuery<T> : FilterValue<T>;
export declare type ObjectQuery<T> = ExpandObject<T> & OperatorMap<T>;
export declare type FilterQuery<T> = ObjectQuery<T> | NonNullable<ExpandScalar<Primary<T>>> | T | FilterQuery<T>[];
export declare type QBFilterQuery<T = any> = FilterQuery<T> | Dictionary;
export interface IWrappedEntity<T extends AnyEntity<T>, PK extends keyof T | unknown = PrimaryProperty<T>, P extends string = string> {
    isInitialized(): boolean;
    isTouched(): boolean;
    populated(populated?: boolean): void;
    init<P extends string = never>(populated?: boolean, populate?: Populate<T, P>, lockMode?: LockMode): Promise<Loaded<T, P>>;
    toReference<PK2 extends PK | unknown = PrimaryProperty<T>, P2 extends string = string>(): IdentifiedReference<T, PK2> & LoadedReference<T>;
    toObject(ignoreFields?: string[]): EntityDTO<T>;
    toJSON(...args: any[]): EntityDTO<T>;
    toPOJO(): EntityDTO<T>;
    assign(data: EntityData<T> | Partial<EntityDTO<T>>, options?: AssignOptions | boolean): T;
    getSchema(): string | undefined;
    setSchema(schema?: string): void;
}
export interface IWrappedEntityInternal<T, PK extends keyof T | unknown = PrimaryProperty<T>, P extends string = string> extends IWrappedEntity<T, PK, P> {
    hasPrimaryKey(): boolean;
    getPrimaryKey(convertCustomTypes?: boolean): Primary<T> | null;
    getPrimaryKeys(convertCustomTypes?: boolean): Primary<T>[] | null;
    setPrimaryKey(val: Primary<T>): void;
    getSerializedPrimaryKey(): string & keyof T;
    __meta: EntityMetadata<T>;
    __data: Dictionary;
    __em?: any;
    __platform: Platform;
    __factory: EntityFactory;
    __initialized: boolean;
    __touched: boolean;
    __originalEntityData?: EntityData<T>;
    __loadedProperties: Set<string>;
    __identifier?: EntityIdentifier;
    __managed: boolean;
    __schema?: string;
    __populated: boolean;
    __onLoadFired: boolean;
    __lazyInitialized: boolean;
    __primaryKeys: Primary<T>[];
    __serializationContext: {
        root?: SerializationContext<T>;
        populate?: PopulateOptions<T>[];
    };
}
export declare type AnyEntity<T = any> = Partial<T> & {
    [PrimaryKeyType]?: unknown;
    [EntityRepositoryType]?: unknown;
    __helper?: IWrappedEntityInternal<T, keyof T>;
    __meta?: EntityMetadata<T>;
    __platform?: Platform;
};
export declare type EntityClass<T extends AnyEntity<T>> = Function & {
    prototype: T;
};
export declare type EntityClassGroup<T extends AnyEntity<T>> = {
    entity: EntityClass<T>;
    schema: EntityMetadata<T> | EntitySchema<T>;
};
export declare type EntityName<T extends AnyEntity<T>> = string | EntityClass<T> | EntitySchema<T, any>;
export declare type GetRepository<T extends AnyEntity<T>, U> = T[typeof EntityRepositoryType] extends EntityRepository<T> | undefined ? NonNullable<T[typeof EntityRepositoryType]> : U;
export declare type EntityDataPropValue<T> = T | Primary<T>;
declare type ExpandEntityProp<T> = T extends Record<string, any> ? {
    [K in keyof T]?: EntityDataProp<ExpandProperty<T[K]>> | EntityDataPropValue<ExpandProperty<T[K]>> | null;
} | EntityDataPropValue<ExpandProperty<T>> : T;
export declare type EntityDataProp<T> = T extends Scalar ? T : T extends Reference<infer U> ? EntityDataNested<U> : T extends Collection<infer U, any> ? U | U[] | EntityDataNested<U> | EntityDataNested<U>[] : T extends readonly (infer U)[] ? U | U[] | EntityDataNested<U> | EntityDataNested<U>[] : EntityDataNested<T>;
export declare type EntityDataNested<T> = T extends undefined ? never : T extends any[] ? Readonly<T> : EntityData<T> | ExpandEntityProp<T>;
declare type EntityDataItem<T> = T | EntityDataProp<T> | null;
declare type ExplicitlyOptionalProps<T> = T extends {
    [OptionalProps]?: infer PK;
} ? PK : never;
declare type NullableKeys<T> = {
    [K in keyof T]: null extends T[K] ? K : never;
}[keyof T];
declare type ProbablyOptionalProps<T> = ExplicitlyOptionalProps<T> | 'id' | '_id' | 'uuid' | Defined<NullableKeys<T>>;
declare type IsOptional<T, K extends keyof T> = T[K] extends Collection<any, any> ? true : T[K] extends Function ? true : K extends symbol ? true : K extends ProbablyOptionalProps<T> ? true : false;
declare type RequiredKeys<T, K extends keyof T> = IsOptional<T, K> extends false ? K : never;
export declare type EntityData<T> = {
    [K in keyof T as ExcludeFunctions<T, K>]?: EntityDataItem<T[K]>;
};
export declare type RequiredEntityData<T> = EntityData<T> & {
    [K in keyof T as RequiredKeys<T, K>]: EntityDataItem<T[K]>;
};
export declare type EntityDictionary<T> = EntityData<T> & Dictionary;
declare type Relation<T> = {
    [P in keyof T as T[P] extends unknown[] | Record<string | number | symbol, unknown> ? P : never]?: T[P];
};
export declare type EntityDTOProp<T> = T extends Scalar ? T : T extends Reference<infer U> ? EntityDTO<U> : T extends {
    getItems(check?: boolean): infer U;
} ? (U extends readonly (infer V)[] ? EntityDTO<V>[] : EntityDTO<U>) : T extends {
    $: infer U;
} ? (U extends readonly (infer V)[] ? EntityDTO<V>[] : EntityDTO<U>) : T extends readonly (infer U)[] ? U[] : T extends Relation<T> ? EntityDTO<T> : T;
export declare type EntityDTO<T> = {
    [K in keyof T as ExcludeFunctions<T, K>]: EntityDTOProp<T[K]>;
};
export declare type CheckCallback<T> = (columns: Record<keyof T, string>) => string;
export interface CheckConstraint<T extends AnyEntity<T> = any> {
    name?: string;
    property?: string;
    expression: string | CheckCallback<T>;
}
export interface EntityProperty<T extends AnyEntity<T> = any> {
    name: string & keyof T;
    entity: () => EntityName<T>;
    type: string;
    targetMeta?: EntityMetadata;
    columnTypes: string[];
    customType: Type<any>;
    autoincrement?: boolean;
    primary?: boolean;
    serializedPrimaryKey: boolean;
    lazy?: boolean;
    array?: boolean;
    length?: number;
    precision?: number;
    scale?: number;
    reference: ReferenceType;
    wrappedReference?: boolean;
    fieldNames: string[];
    fieldNameRaw?: string;
    default?: string | number | boolean | null;
    defaultRaw?: string;
    formula?: (alias: string) => string;
    prefix?: string | boolean;
    embedded?: [string, string];
    embeddable: Constructor<T>;
    embeddedProps: Dictionary<EntityProperty>;
    discriminatorColumn?: string;
    object?: boolean;
    index?: boolean | string;
    unique?: boolean | string;
    nullable?: boolean;
    inherited?: boolean;
    unsigned?: boolean;
    mapToPk?: boolean;
    persist?: boolean;
    hidden?: boolean;
    enum?: boolean;
    items?: (number | string)[];
    version?: boolean;
    concurrencyCheck?: boolean;
    eager?: boolean;
    setter?: boolean;
    getter?: boolean;
    getterName?: keyof T;
    cascade: Cascade[];
    orphanRemoval?: boolean;
    onCreate?: (entity: T) => any;
    onUpdate?: (entity: T) => any;
    onDelete?: 'cascade' | 'no action' | 'set null' | 'set default' | string;
    onUpdateIntegrity?: 'cascade' | 'no action' | 'set null' | 'set default' | string;
    strategy?: LoadStrategy;
    owner: boolean;
    inversedBy: string;
    mappedBy: string;
    orderBy?: QueryOrderMap<T> | QueryOrderMap<T>[];
    customOrder?: string[] | number[] | boolean[];
    fixedOrder?: boolean;
    fixedOrderColumn?: string;
    pivotTable: string;
    joinColumns: string[];
    inverseJoinColumns: string[];
    referencedColumnNames: string[];
    referencedTableName: string;
    referencedPKs: string[];
    serializer?: (value: any) => any;
    serializedName?: string;
    comment?: string;
    /** mysql only */
    extra?: string;
    userDefined?: boolean;
}
export declare class EntityMetadata<T extends AnyEntity<T> = any> {
    readonly propertyOrder: Map<string, number>;
    constructor(meta?: Partial<EntityMetadata>);
    addProperty(prop: EntityProperty<T>, sync?: boolean): void;
    removeProperty(name: string, sync?: boolean): void;
    getPrimaryProps(): EntityProperty<T>[];
    get tableName(): string;
    set tableName(name: string);
    sync(initIndexes?: boolean): void;
    private initIndexes;
}
export interface EntityMetadata<T extends AnyEntity<T> = any> {
    name?: string;
    className: string;
    tableName: string;
    schema?: string;
    pivotTable: boolean;
    discriminatorColumn?: string;
    discriminatorValue?: number | string;
    discriminatorMap?: Dictionary<string>;
    embeddable: boolean;
    constructorParams: string[];
    forceConstructor: boolean;
    toJsonParams: string[];
    extends: string;
    collection: string;
    path: string;
    primaryKeys: (keyof T & string)[];
    compositePK: boolean;
    versionProperty: keyof T & string;
    concurrencyCheckKeys: Set<keyof T & string>;
    serializedPrimaryKey: keyof T & string;
    properties: {
        [K in keyof T & string]: EntityProperty<T>;
    };
    props: EntityProperty<T>[];
    relations: EntityProperty<T>[];
    bidirectionalRelations: EntityProperty<T>[];
    comparableProps: EntityProperty<T>[];
    hydrateProps: EntityProperty<T>[];
    uniqueProps: EntityProperty<T>[];
    indexes: {
        properties: (keyof T & string) | (keyof T & string)[];
        name?: string;
        type?: string;
        options?: Dictionary;
        expression?: string;
    }[];
    uniques: {
        properties: (keyof T & string) | (keyof T & string)[];
        name?: string;
        options?: Dictionary;
    }[];
    checks: CheckConstraint<T>[];
    customRepository: () => Constructor<EntityRepository<T>>;
    hooks: Partial<Record<keyof typeof EventType, (string & keyof T)[]>>;
    prototype: T;
    class: Constructor<T>;
    abstract: boolean;
    useCache: boolean;
    filters: Dictionary<FilterDef>;
    comment?: string;
    selfReferencing?: boolean;
    readonly?: boolean;
    polymorphs?: EntityMetadata[];
    root: EntityMetadata<T>;
    definedProperties: Dictionary;
}
export interface ISchemaGenerator {
    generate(): Promise<string>;
    createSchema(options?: {
        wrap?: boolean;
        schema?: string;
    }): Promise<void>;
    ensureDatabase(): Promise<boolean>;
    getCreateSchemaSQL(options?: {
        wrap?: boolean;
        schema?: string;
    }): Promise<string>;
    dropSchema(options?: {
        wrap?: boolean;
        dropMigrationsTable?: boolean;
        dropDb?: boolean;
        schema?: string;
    }): Promise<void>;
    getDropSchemaSQL(options?: {
        wrap?: boolean;
        dropMigrationsTable?: boolean;
        schema?: string;
    }): Promise<string>;
    updateSchema(options?: {
        wrap?: boolean;
        safe?: boolean;
        dropDb?: boolean;
        dropTables?: boolean;
        schema?: string;
    }): Promise<void>;
    getUpdateSchemaSQL(options?: {
        wrap?: boolean;
        safe?: boolean;
        dropDb?: boolean;
        dropTables?: boolean;
        schema?: string;
    }): Promise<string>;
    getUpdateSchemaMigrationSQL(options?: {
        wrap?: boolean;
        safe?: boolean;
        dropDb?: boolean;
        dropTables?: boolean;
    }): Promise<{
        up: string;
        down: string;
    }>;
    createDatabase(name: string): Promise<void>;
    dropDatabase(name: string): Promise<void>;
    execute(sql: string, options?: {
        wrap?: boolean;
    }): Promise<void>;
    ensureIndexes(): Promise<void>;
    refreshDatabase(): Promise<void>;
    clearDatabase(options?: {
        schema?: string;
    }): Promise<void>;
}
export interface IEntityGenerator {
    generate(options?: {
        baseDir?: string;
        save?: boolean;
        schema?: string;
    }): Promise<string[]>;
}
declare type UmzugMigration = {
    name: string;
    path?: string;
};
declare type MigrateOptions = {
    from?: string | number;
    to?: string | number;
    migrations?: string[];
    transaction?: Transaction;
};
declare type MigrationResult = {
    fileName: string;
    code: string;
    diff: MigrationDiff;
};
declare type MigrationRow = {
    name: string;
    executed_at: Date;
};
export interface IMigrator {
    /**
     * Checks current schema for changes, generates new migration if there are any.
     */
    createMigration(path?: string, blank?: boolean, initial?: boolean): Promise<MigrationResult>;
    /**
     * Creates initial migration. This generates the schema based on metadata, and checks whether all the tables
     * are already present. If yes, it will also automatically log the migration as executed.
     * Initial migration can be created only if the schema is already aligned with the metadata, or when no schema
     * is present - in such case regular migration would have the same effect.
     */
    createInitialMigration(path?: string): Promise<MigrationResult>;
    /**
     * Returns list of already executed migrations.
     */
    getExecutedMigrations(): Promise<MigrationRow[]>;
    /**
     * Returns list of pending (not yet executed) migrations found in the migration directory.
     */
    getPendingMigrations(): Promise<UmzugMigration[]>;
    /**
     * Executes specified migrations. Without parameter it will migrate up to the latest version.
     */
    up(options?: string | string[] | MigrateOptions): Promise<UmzugMigration[]>;
    /**
     * Executes down migrations to the given point. Without parameter it will migrate one version down.
     */
    down(options?: string | string[] | MigrateOptions): Promise<UmzugMigration[]>;
}
export interface MigrationDiff {
    up: string[];
    down: string[];
}
export interface IMigrationGenerator {
    /**
     * Generates the full contents of migration file. Uses `generateMigrationFile` to get the file contents.
     */
    generate(diff: MigrationDiff, path?: string): Promise<[string, string]>;
    /**
     * Creates single migration statement. By default adds `this.addSql(sql);` to the code.
     */
    createStatement(sql: string, padLeft: number): string;
    /**
     * Returns the file contents of given migration.
     */
    generateMigrationFile(className: string, diff: MigrationDiff): string;
}
export interface Migration {
    up(): Promise<void>;
    down(): Promise<void>;
}
export interface MigrationObject {
    name: string;
    class: Constructor<Migration>;
}
export declare type FilterDef = {
    name: string;
    cond: Dictionary | ((args: Dictionary, type: 'read' | 'update' | 'delete', em: any) => Dictionary | Promise<Dictionary>);
    default?: boolean;
    entity?: string[];
    args?: boolean;
};
export declare type Populate<T, P extends string = never> = readonly AutoPath<T, P>[] | boolean;
export declare type PopulateOptions<T> = {
    field: string;
    strategy?: LoadStrategy;
    all?: boolean;
    children?: PopulateOptions<T[keyof T]>[];
};
declare type Loadable<T> = Collection<T, any> | Reference<T> | readonly T[];
declare type ExtractType<T> = T extends Loadable<infer U> ? U : T;
declare type StringKeys<T> = T extends Collection<any, any> ? `${Exclude<keyof ExtractType<T>, symbol>}` : T extends Reference<any> ? `${Exclude<keyof ExtractType<T>, symbol>}` : T extends object ? `${Exclude<keyof ExtractType<T>, symbol>}` : never;
declare type GetStringKey<T, K extends StringKeys<T>> = K extends keyof T ? ExtractType<T[K]> : never;
export declare type AutoPath<O, P extends string> = P extends any ? (P & `${string}.` extends never ? P : P & `${string}.`) extends infer Q ? Q extends `${infer A}.${infer B}` ? A extends StringKeys<O> ? `${A}.${AutoPath<Defined<GetStringKey<O, A>>, B>}` : never : Q extends StringKeys<O> ? (Defined<GetStringKey<O, Q>> extends unknown ? Exclude<P, `${string}.`> : never) | (StringKeys<Defined<GetStringKey<O, Q>>> extends never ? never : `${Q}.`) : StringKeys<O> : never : never;
export declare type ExpandProperty<T> = T extends Reference<infer U> ? NonNullable<U> : T extends Collection<infer U, any> ? NonNullable<U> : T extends (infer U)[] ? NonNullable<U> : NonNullable<T>;
declare type LoadedLoadable<T, E> = T extends Collection<any, any> ? T & LoadedCollection<E> : (T extends Reference<any> ? T & LoadedReference<E> : T & E);
declare type Prefix<K> = K extends `${infer S}.${string}` ? S : K;
declare type Suffix<K> = K extends `${string}.${infer S}` ? S : never;
declare type Defined<T> = Exclude<T, null | undefined>;
export declare type Loaded<T, L extends string = never> = T & {
    [K in keyof T]: K extends Prefix<L> ? LoadedLoadable<T[K], Loaded<ExtractType<T[K]>, Suffix<L>>> : T[K];
};
export interface LoadedReference<T> extends Reference<Defined<T>> {
    $: Defined<T>;
    get(): Defined<T>;
}
export interface LoadedCollection<T> extends Collection<T> {
    $: Collection<T>;
    get(): Collection<T>;
    getItems(check?: boolean): T[];
}
export declare type New<T extends AnyEntity<T>, P extends string = string> = Loaded<T, P>;
export interface Highlighter {
    highlight(text: string): string;
}
export interface IMetadataStorage {
    getAll(): Dictionary<EntityMetadata>;
    get<T extends AnyEntity<T> = any>(entity: string, init?: boolean, validate?: boolean): EntityMetadata<T>;
    find<T extends AnyEntity<T> = any>(entity: string): EntityMetadata<T> | undefined;
    has(entity: string): boolean;
    set(entity: string, meta: EntityMetadata): EntityMetadata;
    reset(entity: string): void;
}
export interface IHydrator {
    /**
     * Hydrates the whole entity. This process handles custom type conversions, creating missing Collection instances,
     * mapping FKs to entity instances, as well as merging those entities.
     */
    hydrate<T extends AnyEntity<T>>(entity: T, meta: EntityMetadata<T>, data: EntityData<T>, factory: EntityFactory, type: 'full' | 'returning' | 'reference', newEntity?: boolean, convertCustomTypes?: boolean, schema?: string): void;
    /**
     * Hydrates primary keys only
     */
    hydrateReference<T extends AnyEntity<T>>(entity: T, meta: EntityMetadata<T>, data: EntityData<T>, factory: EntityFactory, convertCustomTypes?: boolean, schema?: string): void;
}
export interface HydratorConstructor {
    new (metadata: MetadataStorage, platform: Platform, config: Configuration): IHydrator;
}
export interface ISeedManager {
    seed(...classNames: Constructor<Seeder>[]): Promise<void>;
    /** @internal */
    seedString(...classNames: string[]): Promise<void>;
    createSeeder(className: string): Promise<string>;
}
export interface Seeder {
    run(em: EntityManager): Promise<void>;
}
export declare type MaybePromise<T> = T | Promise<T>;
export {};
