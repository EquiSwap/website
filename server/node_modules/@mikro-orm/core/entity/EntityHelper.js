"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityHelper = void 0;
const util_1 = require("util");
const EntityTransformer_1 = require("./EntityTransformer");
const Reference_1 = require("./Reference");
const Utils_1 = require("../utils/Utils");
const WrappedEntity_1 = require("./WrappedEntity");
const enums_1 = require("../enums");
const entityHelperSymbol = Symbol('helper');
class EntityHelper {
    static decorate(meta, em) {
        const fork = em.fork(); // use fork so we can access `EntityFactory`
        if (meta.embeddable) {
            EntityHelper.defineBaseProperties(meta, meta.prototype, fork);
            return;
        }
        const pk = meta.properties[meta.primaryKeys[0]];
        if (pk.name === '_id' && meta.serializedPrimaryKey === 'id') {
            EntityHelper.defineIdProperty(meta, em.getPlatform());
        }
        EntityHelper.defineBaseProperties(meta, meta.prototype, fork);
        EntityHelper.defineProperties(meta);
        const prototype = meta.prototype;
        if (!prototype.toJSON) { // toJSON can be overridden
            prototype.toJSON = function (...args) {
                return EntityTransformer_1.EntityTransformer.toObject(this, ...args.slice(meta.toJsonParams.length));
            };
        }
    }
    /**
     * defines magic id property getter/setter if PK property is `_id` and there is no `id` property defined
     */
    static defineIdProperty(meta, platform) {
        Object.defineProperty(meta.prototype, 'id', {
            get() {
                return this._id ? platform.normalizePrimaryKey(this._id) : null;
            },
            set(id) {
                this._id = id ? platform.denormalizePrimaryKey(id) : null;
            },
        });
    }
    /**
     * As a performance optimization, we create entity state methods in a lazy manner. We first add
     * the `null` value to the prototype to reserve space in memory. Then we define a setter on the
     * prototype, that will be executed exactly once per entity instance. There we redefine given
     * property on the entity instance, so shadowing the prototype setter.
     */
    static defineBaseProperties(meta, prototype, em) {
        const helperParams = meta.embeddable ? [] : [em.getComparator().getPkGetter(meta), em.getComparator().getPkSerializer(meta), em.getComparator().getPkGetterConverted(meta)];
        Object.defineProperties(prototype, {
            __entity: { value: !meta.embeddable },
            __meta: { value: meta },
            __platform: { value: em.getPlatform() },
            __factory: { value: em.getEntityFactory() },
            [entityHelperSymbol]: { value: null, writable: true, enumerable: false },
            __helper: {
                get() {
                    if (!this[entityHelperSymbol]) {
                        Object.defineProperty(this, entityHelperSymbol, {
                            value: new WrappedEntity_1.WrappedEntity(this, ...helperParams),
                            enumerable: false,
                        });
                    }
                    return this[entityHelperSymbol];
                },
            },
        });
    }
    /**
     * Defines getter and setter for every owning side of m:1 and 1:1 relation. This is then used for propagation of
     * changes to the inverse side of bi-directional relations. Rest of the properties are also defined this way to
     * achieve dirtyness, which is then used for fast checks whether we need to auto-flush because of managed entities.
     *
     * First defines a setter on the prototype, once called, actual get/set handlers are registered on the instance rather
     * than on its prototype. Thanks to this we still have those properties enumerable (e.g. part of `Object.keys(entity)`).
     */
    static defineProperties(meta) {
        Object
            .values(meta.properties)
            .forEach(prop => {
            const isCollection = [enums_1.ReferenceType.ONE_TO_MANY, enums_1.ReferenceType.MANY_TO_MANY].includes(prop.reference);
            const isReference = [enums_1.ReferenceType.ONE_TO_ONE, enums_1.ReferenceType.MANY_TO_ONE].includes(prop.reference) && (prop.inversedBy || prop.mappedBy) && !prop.mapToPk;
            if (isReference) {
                return Object.defineProperty(meta.prototype, prop.name, {
                    set(val) {
                        EntityHelper.defineReferenceProperty(meta, prop, this);
                        this[prop.name] = val;
                    },
                });
            }
            if (prop.inherited || prop.primary || prop.persist === false || prop.embedded || isCollection) {
                return;
            }
            Object.defineProperty(meta.prototype, prop.name, {
                set(val) {
                    Object.defineProperty(this, prop.name, {
                        get() {
                            return this.__helper.__data[prop.name];
                        },
                        set(val) {
                            this.__helper.__data[prop.name] = val;
                            this.__helper.__touched = true;
                        },
                        enumerable: true,
                        configurable: true,
                    });
                    this.__helper.__data[prop.name] = val;
                    this.__helper.__touched = true;
                },
            });
        });
        /* istanbul ignore else */
        if (!meta.prototype[util_1.inspect.custom]) {
            meta.prototype[util_1.inspect.custom] = function (depth) {
                const object = { ...this };
                delete object[entityHelperSymbol];
                const ret = (0, util_1.inspect)(object, { depth });
                let name = this.constructor.name;
                // distinguish not initialized entities
                if (!this.__helper.__initialized) {
                    name = `Ref<${name}>`;
                }
                return ret === '[Object]' ? `[${name}]` : name + ' ' + ret;
            };
        }
    }
    static defineReferenceProperty(meta, prop, ref) {
        Object.defineProperty(ref, prop.name, {
            get() {
                return this.__helper.__data[prop.name];
            },
            set(val) {
                const entity = Reference_1.Reference.unwrapReference(val ?? this.__helper.__data[prop.name]);
                this.__helper.__data[prop.name] = Reference_1.Reference.wrapReference(val, prop);
                this.__helper.__touched = true;
                EntityHelper.propagate(meta, entity, this, prop, Reference_1.Reference.unwrapReference(val));
            },
            enumerable: true,
            configurable: true,
        });
    }
    static propagate(meta, entity, owner, prop, value) {
        const inverseProps = prop.targetMeta.relations.filter(prop2 => (prop2.inversedBy || prop2.mappedBy) === prop.name && prop2.targetMeta.root.className === meta.root.className);
        for (const prop2 of inverseProps) {
            const inverse = value?.[prop2.name];
            if (prop.reference === enums_1.ReferenceType.MANY_TO_ONE && Utils_1.Utils.isCollection(inverse) && inverse.isInitialized()) {
                inverse.add(owner);
            }
            if (prop.reference === enums_1.ReferenceType.ONE_TO_ONE && entity && entity.__helper.__initialized && Reference_1.Reference.unwrapReference(inverse) !== owner && value != null) {
                EntityHelper.propagateOneToOne(entity, owner, prop, prop2);
            }
            if (prop.reference === enums_1.ReferenceType.ONE_TO_ONE && entity && entity.__helper.__initialized && entity[prop2.name] != null && value == null) {
                entity[prop2.name] = value;
                if (prop.orphanRemoval) {
                    entity.__helper.__em?.getUnitOfWork().scheduleOrphanRemoval(entity);
                }
            }
        }
    }
    static propagateOneToOne(entity, owner, prop, prop2) {
        const inverse = entity[prop2.name];
        if (Reference_1.Reference.isReference(inverse)) {
            inverse.set(owner);
        }
        else {
            entity[prop2.name] = Reference_1.Reference.wrapReference(owner, prop);
        }
    }
}
exports.EntityHelper = EntityHelper;
