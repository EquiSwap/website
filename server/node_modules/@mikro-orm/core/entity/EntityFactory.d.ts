import type { AnyEntity, EntityData, EntityMetadata, EntityName, New, Primary } from '../typings';
import type { EntityManager } from '../EntityManager';
export interface FactoryOptions {
    initialized?: boolean;
    newEntity?: boolean;
    merge?: boolean;
    refresh?: boolean;
    convertCustomTypes?: boolean;
    schema?: string;
}
export declare class EntityFactory {
    private readonly em;
    private readonly driver;
    private readonly platform;
    private readonly config;
    private readonly metadata;
    private readonly hydrator;
    private readonly eventManager;
    private readonly comparator;
    constructor(em: EntityManager);
    create<T extends AnyEntity<T>, P extends string = string>(entityName: EntityName<T>, data: EntityData<T>, options?: FactoryOptions): New<T, P>;
    mergeData<T extends AnyEntity<T>>(meta: EntityMetadata<T>, entity: T, data: EntityData<T>, options: FactoryOptions): void;
    createReference<T>(entityName: EntityName<T>, id: Primary<T> | Primary<T>[] | Record<string, Primary<T>>, options?: Pick<FactoryOptions, 'merge' | 'convertCustomTypes' | 'schema'>): T;
    createEmbeddable<T>(entityName: EntityName<T>, data: EntityData<T>, options?: Pick<FactoryOptions, 'newEntity' | 'convertCustomTypes'>): T;
    private createEntity;
    private hydrate;
    private findEntity;
    private processDiscriminatorColumn;
    /**
     * denormalize PK to value required by driver (e.g. ObjectId)
     */
    private denormalizePrimaryKey;
    /**
     * returns parameters for entity constructor, creating references from plain ids
     */
    private extractConstructorParams;
    private get unitOfWork();
}
