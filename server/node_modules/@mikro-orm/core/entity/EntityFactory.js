"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityFactory = void 0;
const Utils_1 = require("../utils/Utils");
const enums_1 = require("../enums");
const Reference_1 = require("./Reference");
class EntityFactory {
    constructor(em) {
        this.em = em;
        this.driver = this.em.getDriver();
        this.platform = this.driver.getPlatform();
        this.config = this.em.config;
        this.metadata = this.em.getMetadata();
        this.hydrator = this.config.getHydrator(this.metadata);
        this.eventManager = this.em.getEventManager();
        this.comparator = this.em.getComparator();
    }
    create(entityName, data, options = {}) {
        data = Reference_1.Reference.unwrapReference(data);
        options.initialized ?? (options.initialized = true);
        if (data.__entity) {
            return data;
        }
        entityName = Utils_1.Utils.className(entityName);
        const meta = this.metadata.get(entityName);
        if (this.platform.usesDifferentSerializedPrimaryKey()) {
            meta.primaryKeys.forEach(pk => this.denormalizePrimaryKey(data, pk, meta.properties[pk]));
        }
        const meta2 = this.processDiscriminatorColumn(meta, data);
        const exists = this.findEntity(data, meta2, options);
        if (exists && exists.__helper.__initialized && !options.refresh) {
            exists.__helper.__initialized = options.initialized;
            this.mergeData(meta2, exists, data, options);
            return exists;
        }
        data = { ...data };
        const entity = exists ?? this.createEntity(data, meta2, options);
        entity.__helper.__initialized = options.initialized;
        this.hydrate(entity, meta2, data, options);
        entity.__helper.__touched = false;
        if (exists && meta.discriminatorColumn && !(entity instanceof meta2.class)) {
            Object.setPrototypeOf(entity, meta2.prototype);
        }
        if (options.merge && entity.__helper.hasPrimaryKey()) {
            this.unitOfWork.registerManaged(entity, data, {
                refresh: options.refresh && options.initialized,
                newEntity: options.newEntity,
                loaded: options.initialized,
            });
        }
        if (this.eventManager.hasListeners(enums_1.EventType.onInit, meta2)) {
            this.eventManager.dispatchEvent(enums_1.EventType.onInit, { entity, em: this.em });
        }
        return entity;
    }
    mergeData(meta, entity, data, options) {
        // merge unchanged properties automatically
        data = { ...data };
        const existsData = this.comparator.prepareEntity(entity);
        const originalEntityData = entity.__helper.__originalEntityData ?? {};
        const diff = this.comparator.diffEntities(meta.className, originalEntityData, existsData);
        // version properties are not part of entity snapshots
        if (meta.versionProperty && data[meta.versionProperty] && data[meta.versionProperty] !== originalEntityData[meta.versionProperty]) {
            diff[meta.versionProperty] = data[meta.versionProperty];
        }
        const diff2 = this.comparator.diffEntities(meta.className, existsData, data);
        // do not override values changed by user
        Object.keys(diff).forEach(key => delete diff2[key]);
        Object.keys(diff2).filter(key => diff2[key] === undefined).forEach(key => delete diff2[key]);
        this.hydrate(entity, meta, diff2, options);
        // we need to update the entity data only with keys that were not present before
        Object.keys(diff2).forEach(key => {
            const prop = meta.properties[key];
            if ([enums_1.ReferenceType.MANY_TO_ONE, enums_1.ReferenceType.ONE_TO_ONE].includes(prop.reference) && Utils_1.Utils.isPlainObject(data[prop.name])) {
                diff2[key] = entity[prop.name].__helper.getPrimaryKey(options.convertCustomTypes);
            }
            originalEntityData[key] = diff2[key];
            entity.__helper.__loadedProperties.add(key);
        });
        // in case of joined loading strategy, we need to cascade the merging to possibly loaded relations manually
        meta.relations.forEach(prop => {
            if ([enums_1.ReferenceType.MANY_TO_MANY, enums_1.ReferenceType.ONE_TO_MANY].includes(prop.reference) && Array.isArray(data[prop.name])) {
                // instead of trying to match the collection items (which could easily fail if the collection was loaded with different ordering),
                // we just create the entity from scratch, which will automatically pick the right one from the identity map and call `mergeData` on it
                data[prop.name]
                    .filter(child => Utils_1.Utils.isPlainObject(child)) // objects with prototype can be PKs (e.g. `ObjectId`)
                    .forEach(child => this.create(prop.type, child, options)); // we can ignore the value, we just care about the `mergeData` call
                return;
            }
            if ([enums_1.ReferenceType.MANY_TO_ONE, enums_1.ReferenceType.ONE_TO_ONE].includes(prop.reference) && Utils_1.Utils.isPlainObject(data[prop.name]) && entity[prop.name] && entity[prop.name].__helper.__initialized) {
                this.create(prop.type, data[prop.name], options); // we can ignore the value, we just care about the `mergeData` call
            }
        });
        entity.__helper.__touched = false;
    }
    createReference(entityName, id, options = {}) {
        options.convertCustomTypes ?? (options.convertCustomTypes = true);
        entityName = Utils_1.Utils.className(entityName);
        const meta = this.metadata.get(entityName);
        const schema = this.driver.getSchemaName(meta, options);
        if (Array.isArray(id)) {
            id = Utils_1.Utils.getPrimaryKeyCondFromArray(id, meta);
        }
        const pks = Utils_1.Utils.getOrderedPrimaryKeys(id, meta, this.platform, options.convertCustomTypes);
        if (Utils_1.Utils.isPrimaryKey(id)) {
            id = { [meta.primaryKeys[0]]: id };
        }
        const exists = this.unitOfWork.getById(entityName, pks, schema);
        if (exists) {
            return exists;
        }
        return this.create(entityName, id, { ...options, initialized: false });
    }
    createEmbeddable(entityName, data, options = {}) {
        entityName = Utils_1.Utils.className(entityName);
        data = { ...data };
        const meta = this.metadata.get(entityName);
        const meta2 = this.processDiscriminatorColumn(meta, data);
        return this.createEntity(data, meta2, options);
    }
    createEntity(data, meta, options) {
        if (options.newEntity || meta.forceConstructor) {
            if (!meta.class) {
                throw new Error(`Cannot create entity ${meta.className}, class prototype is unknown`);
            }
            options.initialized = options.newEntity || options.initialized;
            const params = this.extractConstructorParams(meta, data, options);
            const Entity = meta.class;
            meta.constructorParams.forEach(prop => delete data[prop]);
            // creates new instance via constructor as this is the new entity
            const entity = new Entity(...params);
            entity.__helper.__schema = this.driver.getSchemaName(meta, options);
            if (!options.newEntity) {
                meta.relations
                    .filter(prop => [enums_1.ReferenceType.ONE_TO_MANY, enums_1.ReferenceType.MANY_TO_MANY].includes(prop.reference))
                    .forEach(prop => delete entity[prop.name]);
                if (options.initialized && !entity.__gettersDefined) {
                    Object.defineProperties(entity, meta.definedProperties);
                }
            }
            return entity;
        }
        // creates new entity instance, bypassing constructor call as its already persisted entity
        const entity = Object.create(meta.class.prototype);
        entity.__helper.__managed = true;
        entity.__helper.__schema = this.driver.getSchemaName(meta, options);
        if (options.merge && !options.newEntity) {
            this.hydrator.hydrateReference(entity, meta, data, this, options.convertCustomTypes, this.driver.getSchemaName(meta, options));
            this.unitOfWork.registerManaged(entity);
        }
        if (options.initialized && !entity.__gettersDefined) {
            Object.defineProperties(entity, meta.definedProperties);
        }
        return entity;
    }
    hydrate(entity, meta, data, options) {
        if (options.initialized) {
            this.hydrator.hydrate(entity, meta, data, this, 'full', options.newEntity, options.convertCustomTypes, this.driver.getSchemaName(meta, options));
        }
        else {
            this.hydrator.hydrateReference(entity, meta, data, this, options.convertCustomTypes, this.driver.getSchemaName(meta, options));
        }
        Object.keys(data).forEach(key => entity.__helper.__loadedProperties.add(key));
    }
    findEntity(data, meta, options) {
        const schema = this.driver.getSchemaName(meta, options);
        if (!meta.compositePK && !meta.getPrimaryProps()[0]?.customType) {
            return this.unitOfWork.getById(meta.name, data[meta.primaryKeys[0]], schema);
        }
        if (meta.primaryKeys.some(pk => data[pk] == null)) {
            return undefined;
        }
        const pks = Utils_1.Utils.getOrderedPrimaryKeys(data, meta, this.platform, options.convertCustomTypes);
        return this.unitOfWork.getById(meta.name, pks, schema);
    }
    processDiscriminatorColumn(meta, data) {
        if (!meta.root.discriminatorColumn) {
            return meta;
        }
        const prop = meta.properties[meta.root.discriminatorColumn];
        const value = data[prop.name];
        const type = meta.root.discriminatorMap[value];
        meta = type ? this.metadata.find(type) : meta;
        // `prop.userDefined` is either `undefined` or `false`
        if (prop.userDefined === false) {
            delete data[prop.name];
        }
        return meta;
    }
    /**
     * denormalize PK to value required by driver (e.g. ObjectId)
     */
    denormalizePrimaryKey(data, primaryKey, prop) {
        const pk = this.platform.getSerializedPrimaryKeyField(primaryKey);
        if (data[pk] != null || data[primaryKey] != null) {
            let id = data[pk] || data[primaryKey];
            if (prop.type.toLowerCase() === 'objectid') {
                id = this.platform.denormalizePrimaryKey(id);
            }
            delete data[pk];
            data[primaryKey] = id;
        }
    }
    /**
     * returns parameters for entity constructor, creating references from plain ids
     */
    extractConstructorParams(meta, data, options) {
        return meta.constructorParams.map(k => {
            if (meta.properties[k] && [enums_1.ReferenceType.MANY_TO_ONE, enums_1.ReferenceType.ONE_TO_ONE].includes(meta.properties[k].reference) && data[k]) {
                const entity = this.unitOfWork.getById(meta.properties[k].type, data[k], options.schema);
                if (entity) {
                    return entity;
                }
                if (Utils_1.Utils.isEntity(data[k])) {
                    return data[k];
                }
                return this.createReference(meta.properties[k].type, data[k], options);
            }
            if (meta.properties[k]?.reference === enums_1.ReferenceType.EMBEDDED && data[k]) {
                /* istanbul ignore next */
                if (Utils_1.Utils.isEntity(data[k])) {
                    return data[k];
                }
                return this.createEmbeddable(meta.properties[k].type, data[k], options);
            }
            if (!meta.properties[k]) {
                return data;
            }
            return data[k];
        });
    }
    get unitOfWork() {
        return this.em.getUnitOfWork(false);
    }
}
exports.EntityFactory = EntityFactory;
