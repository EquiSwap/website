import type { AnyEntity, Dictionary, EntityMetadata, EntityProperty, FilterDef, FilterQuery } from '../typings';
import type { Platform } from '../platforms';
import type { MetadataStorage } from '../metadata/MetadataStorage';
export declare class QueryHelper {
    static readonly SUPPORTED_OPERATORS: string[];
    static processParams(params: any): any;
    static processObjectParams(params?: Dictionary): any;
    static inlinePrimaryKeyObjects<T extends AnyEntity<T>>(where: Dictionary, meta: EntityMetadata<T>, metadata: MetadataStorage, key?: string): boolean;
    static processWhere<T>(where: FilterQuery<T>, entityName: string, metadata: MetadataStorage, platform: Platform, convertCustomTypes?: boolean, root?: boolean): FilterQuery<T>;
    static getActiveFilters(entityName: string, options: Dictionary<boolean | Dictionary> | string[] | boolean, filters: Dictionary<FilterDef>): FilterDef[];
    static isFilterActive(entityName: string, filterName: string, filter: FilterDef, options: Dictionary<boolean | Dictionary>): boolean;
    static processCustomType<T>(prop: EntityProperty<T>, cond: FilterQuery<T>, platform: Platform, key?: string, fromQuery?: boolean): FilterQuery<T>;
    private static processExpression;
    private static isSupportedOperator;
    private static processJsonCondition;
}
/**
 * Helper for escaping string types, e.g. `keyof T -> string`.
 * We can also pass array of strings to allow tuple comparison in SQL drivers.
 * Another alternative is to use callback signature, which will give us the current alias in its parameter.
 */
export declare function expr<T = unknown>(sql: (keyof T & string) | (keyof T & string)[] | ((alias: string) => string)): string;
