"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = exports.equals = exports.compareBuffers = exports.compareArrays = exports.compareObjects = exports.ObjectBindingPattern = void 0;
const module_1 = require("module");
const globby_1 = __importDefault(require("globby"));
const path_1 = require("path");
const os_1 = require("os");
const url_1 = require("url");
const fs_extra_1 = require("fs-extra");
const crypto_1 = require("crypto");
const escaya_1 = require("escaya");
const clone_1 = require("./clone");
const enums_1 = require("../enums");
exports.ObjectBindingPattern = Symbol('ObjectBindingPattern');
function compareObjects(a, b) {
    // eslint-disable-next-line eqeqeq
    if (a === b || (a == null && b == null)) {
        return true;
    }
    if (!a || !b || typeof a !== 'object' || typeof b !== 'object' || a.constructor !== b.constructor) {
        return false;
    }
    if (a.valueOf !== Object.prototype.valueOf) {
        return a.valueOf() === b.valueOf();
    }
    if (a.toString !== Object.prototype.toString) {
        return a.toString() === b.toString();
    }
    const keys = Object.keys(a);
    const length = keys.length;
    if (length !== Object.keys(b).length) {
        return false;
    }
    for (let i = length; i-- !== 0;) {
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
            return false;
        }
    }
    for (let i = length; i-- !== 0;) {
        const key = keys[i];
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        if (!equals(a[key], b[key])) {
            return false;
        }
    }
    return true;
}
exports.compareObjects = compareObjects;
function compareArrays(a, b) {
    const length = a.length;
    if (length !== b.length) {
        return false;
    }
    for (let i = length; i-- !== 0;) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        if (!equals(a[i], b[i])) {
            return false;
        }
    }
    return true;
}
exports.compareArrays = compareArrays;
function compareBuffers(a, b) {
    const length = a.length;
    if (length !== b.length) {
        return false;
    }
    for (let i = length; i-- !== 0;) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.compareBuffers = compareBuffers;
/**
 * Checks if arguments are deeply (but not strictly) equal.
 */
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        if (Array.isArray(a)) {
            return compareArrays(a, b);
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
            return compareBuffers(a, b);
        }
        return compareObjects(a, b);
    }
    return false;
}
exports.equals = equals;
const equalsFn = equals;
class Utils {
    /**
     * Checks if the argument is not undefined
     */
    static isDefined(data) {
        return typeof data !== 'undefined';
    }
    /**
     * Checks if the argument is instance of `Object`. Returns false for arrays.
     */
    static isObject(o) {
        return !!o && typeof o === 'object' && !Array.isArray(o);
    }
    /**
     * Checks if the argument is instance of `Object`, but not one of the blacklisted types. Returns false for arrays.
     */
    static isNotObject(o, not) {
        return this.isObject(o) && !not.some(cls => o instanceof cls);
    }
    /**
     * Removes `undefined` properties (recursively) so they are not saved as nulls
     */
    static dropUndefinedProperties(o) {
        if (Array.isArray(o)) {
            return o.forEach((item) => Utils.dropUndefinedProperties(item));
        }
        if (!Utils.isObject(o)) {
            return;
        }
        Object.keys(o).forEach(key => {
            if (o[key] === undefined) {
                delete o[key];
                return;
            }
            Utils.dropUndefinedProperties(o[key]);
        });
    }
    /**
     * Returns the number of properties on `obj`. This is 20x faster than Object.keys(obj).length.
     * @see https://github.com/deepkit/deepkit-framework/blob/master/packages/core/src/core.ts
     */
    static getObjectKeysSize(object) {
        let size = 0;
        for (const key in object) {
            /* istanbul ignore else */ // eslint-disable-next-line no-prototype-builtins
            if (object.hasOwnProperty(key)) {
                size++;
            }
        }
        return size;
    }
    /**
     * Returns true if `obj` has at least one property. This is 20x faster than Object.keys(obj).length.
     * @see https://github.com/deepkit/deepkit-framework/blob/master/packages/core/src/core.ts
     */
    static hasObjectKeys(object) {
        for (const key in object) {
            /* istanbul ignore else */ // eslint-disable-next-line no-prototype-builtins
            if (object.hasOwnProperty(key)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Checks if the argument is string
     */
    static isString(s) {
        return typeof s === 'string';
    }
    /**
     * Checks if the argument is number
     */
    static isNumber(s) {
        return typeof s === 'number';
    }
    /**
     * Checks if arguments are deeply (but not strictly) equal.
     */
    static equals(a, b) {
        return equalsFn(a, b);
    }
    /**
     * Gets array without duplicates.
     */
    static unique(items) {
        return [...new Set(items)];
    }
    /**
     * Merges all sources into the target recursively.
     */
    static merge(target, ...sources) {
        if (!sources.length) {
            return target;
        }
        const source = sources.shift();
        if (Utils.isObject(target) && Utils.isPlainObject(source)) {
            Object.entries(source).forEach(([key, value]) => {
                if (Utils.isPlainObject(value)) {
                    if (!(key in target)) {
                        Object.assign(target, { [key]: {} });
                    }
                    Utils.merge(target[key], value);
                }
                else {
                    Object.assign(target, { [key]: value });
                }
            });
        }
        return Utils.merge(target, ...sources);
    }
    static getRootEntity(metadata, meta) {
        const base = meta.extends && metadata.find(meta.extends);
        if (!base || base === meta) { // make sure we do not fall into infinite loop
            return meta;
        }
        const root = Utils.getRootEntity(metadata, base);
        if (root.discriminatorColumn) {
            return root;
        }
        return meta;
    }
    /**
     * Computes difference between two objects, ignoring items missing in `b`.
     */
    static diff(a, b) {
        const ret = {};
        Object.keys(b).forEach(k => {
            if (Utils.equals(a[k], b[k])) {
                return;
            }
            ret[k] = b[k];
        });
        return ret;
    }
    /**
     * Creates deep copy of given object.
     */
    static copy(entity) {
        return (0, clone_1.clone)(entity);
    }
    /**
     * Normalize the argument to always be an array.
     */
    static asArray(data, strict = false) {
        if (typeof data === 'undefined' && !strict) {
            return [];
        }
        if (data instanceof Set) {
            return Array.from(data);
        }
        return Array.isArray(data) ? data : [data];
    }
    /**
     * Renames object key, keeps order of properties.
     */
    static renameKey(payload, from, to) {
        if (Utils.isObject(payload) && from in payload && !(to in payload)) {
            Object.keys(payload).forEach(key => {
                const value = payload[key];
                delete payload[key];
                payload[from === key ? to : key] = value;
            }, payload);
        }
    }
    /**
     * Returns array of functions argument names. Uses `escaya` for source code analysis.
     */
    static getParamNames(func, methodName) {
        const ret = [];
        const parsed = (0, escaya_1.recovery)(func.toString(), 'entity.js', { next: true, module: true });
        const checkNode = (node) => {
            if (methodName && node.name?.name !== methodName) {
                return;
            }
            const params = node.uniqueFormalParameters ?? node.params;
            ret.push(...params.map((p) => {
                switch (p.type) {
                    case 'BindingElement':
                        if (p.left.type === 'ObjectBindingPattern') {
                            return exports.ObjectBindingPattern;
                        }
                        return p.left.name;
                    case 'BindingRestElement':
                        return '...' + p.argument.name;
                    default:
                        return p.name;
                }
            }));
        };
        Utils.walkNode(parsed, checkNode);
        return ret;
    }
    static walkNode(node, checkNode) {
        if (['MethodDefinition', 'FunctionDeclaration'].includes(node.type)) {
            checkNode(node);
        }
        if (Array.isArray(node.leafs)) {
            node.leafs.forEach((row) => Utils.walkNode(row, checkNode));
        }
        if (Array.isArray(node.elements)) {
            node.elements.forEach(element => Utils.walkNode(element, checkNode));
        }
        if (node.method) {
            Utils.walkNode(node.method, checkNode);
        }
    }
    /**
     * Checks whether the argument looks like primary key (string, number or ObjectId).
     */
    static isPrimaryKey(key, allowComposite = false) {
        if (allowComposite && Array.isArray(key) && key.every((v, i) => Utils.isPrimaryKey(v, true))) {
            return true;
        }
        if (Utils.isObject(key) && !Utils.isPlainObject(key) && !Utils.isEntity(key, true)) {
            return true;
        }
        return ['string', 'number', 'bigint'].includes(typeof key) || Utils.isObjectID(key) || key instanceof Date || key instanceof Buffer;
    }
    /**
     * Extracts primary key from `data`. Accepts objects or primary keys directly.
     */
    static extractPK(data, meta, strict = false) {
        if (Utils.isPrimaryKey(data)) {
            return data;
        }
        if (Utils.isEntity(data, true)) {
            return data.__helper.getPrimaryKey();
        }
        if (strict && meta && Utils.getObjectKeysSize(data) !== meta.primaryKeys.length) {
            return null;
        }
        if (Utils.isPlainObject(data) && meta) {
            if (meta.compositePK) {
                return Utils.getCompositeKeyHash(data, meta);
            }
            return data[meta.primaryKeys[0]] || data[meta.serializedPrimaryKey] || null;
        }
        return null;
    }
    static getCompositeKeyHash(data, meta) {
        const pks = meta.primaryKeys.map(pk => {
            const value = data[pk];
            const prop = meta.properties[pk];
            if (prop.targetMeta && Utils.isPlainObject(value)) {
                return this.getCompositeKeyHash(value, prop.targetMeta);
            }
            return value;
        });
        return Utils.getPrimaryKeyHash(pks);
    }
    static getPrimaryKeyHash(pks) {
        return pks.join(this.PK_SEPARATOR);
    }
    static splitPrimaryKeys(key) {
        return key.split(this.PK_SEPARATOR);
    }
    static getPrimaryKeyValues(entity, primaryKeys, allowScalar = false, convertCustomTypes = false) {
        if (allowScalar && primaryKeys.length === 1) {
            if (Utils.isEntity(entity[primaryKeys[0]], true)) {
                return entity[primaryKeys[0]].__helper.getPrimaryKey(convertCustomTypes);
            }
            return entity[primaryKeys[0]];
        }
        return primaryKeys.reduce((ret, pk) => {
            if (Utils.isEntity(entity[pk], true)) {
                const childPk = entity[pk].__helper.getPrimaryKey(convertCustomTypes);
                if (entity[pk].__meta.compositePK) {
                    ret.push(...Object.values(childPk));
                }
                else {
                    ret.push(childPk);
                }
            }
            else {
                ret.push(entity[pk]);
            }
            return ret;
        }, []);
    }
    static getPrimaryKeyCond(entity, primaryKeys) {
        const cond = primaryKeys.reduce((o, pk) => {
            o[pk] = Utils.extractPK(entity[pk]);
            return o;
        }, {});
        if (Object.values(cond).some(v => v === null)) {
            return null;
        }
        return cond;
    }
    static getPrimaryKeyCondFromArray(pks, meta) {
        return meta.getPrimaryProps().reduce((o, pk, idx) => {
            if (Array.isArray(pks[idx]) && pk.targetMeta) {
                o[pk.name] = Utils.getPrimaryKeyCondFromArray(pks[idx], pk.targetMeta);
            }
            else {
                o[pk.name] = Utils.extractPK(pks[idx]);
            }
            return o;
        }, {});
    }
    static getOrderedPrimaryKeys(id, meta, platform, convertCustomTypes) {
        const data = (Utils.isPrimaryKey(id) ? { [meta.primaryKeys[0]]: id } : id);
        const pks = meta.primaryKeys.map((pk, idx) => {
            const prop = meta.properties[pk];
            // `data` can be a composite PK in form of array of PKs, or a DTO
            let value = Array.isArray(data) ? data[idx] : data[pk];
            if (prop.reference !== enums_1.ReferenceType.SCALAR && prop.targetMeta) {
                const value2 = this.getOrderedPrimaryKeys(value, prop.targetMeta, platform); // do not convert custom types yet
                value = value2.length > 1 ? value2 : value2[0];
            }
            if (prop.customType && platform && convertCustomTypes) {
                return prop.customType.convertToJSValue(value, platform);
            }
            return value;
        });
        // we need to flatten the PKs as composite PKs can be build from another composite PKs
        // and this method is used to get the PK hash in identity map, that expects flat array
        return Utils.flatten(pks);
    }
    /**
     * Checks whether given object is an entity instance.
     */
    static isEntity(data, allowReference = false) {
        if (!Utils.isObject(data)) {
            return false;
        }
        if (allowReference && !!data.__reference) {
            return true;
        }
        return !!data.__entity;
    }
    /**
     * Checks whether the argument is ObjectId instance
     */
    static isObjectID(key) {
        return Utils.isObject(key) && key.constructor && key.constructor.name.toLowerCase() === 'objectid';
    }
    /**
     * Checks whether the argument is empty (array without items, object without keys or falsy value).
     */
    static isEmpty(data) {
        if (Array.isArray(data)) {
            return data.length === 0;
        }
        if (Utils.isObject(data)) {
            return !Utils.hasObjectKeys(data);
        }
        return !data;
    }
    /**
     * Gets string name of given class.
     */
    static className(classOrName) {
        if (Utils.isString(classOrName)) {
            return classOrName;
        }
        return classOrName.name;
    }
    /**
     * Tries to detect `ts-node` runtime.
     */
    static detectTsNode() {
        /* istanbul ignore next */
        return process.argv[0].endsWith('ts-node') // running via ts-node directly
            || !!process[Symbol.for('ts-node.register.instance')] // check if internal ts-node symbol exists
            || !!process.env.TS_JEST // check if ts-jest is used (works only with v27.0.4+)
            || process.argv.slice(1).some(arg => arg.includes('ts-node')) // registering ts-node runner
            || (require.extensions && !!require.extensions['.ts']); // check if the extension is registered
    }
    /**
     * Uses some dark magic to get source path to caller where decorator is used.
     * Analyses stack trace of error created inside the function call.
     */
    static lookupPathFromDecorator(name, stack) {
        // use some dark magic to get source path to caller
        stack = stack || new Error().stack.split('\n');
        let line = stack.findIndex(line => line.includes('__decorate'));
        if (line === -1) {
            return name;
        }
        if (Utils.normalizePath(stack[line]).includes('node_modules/tslib/tslib')) {
            line++;
        }
        try {
            const re = stack[line].match(/\(.+\)/i) ? /\((.*):\d+:\d+\)/ : /at\s*(.*):\d+:\d+$/;
            return Utils.normalizePath(stack[line].match(re)[1]);
        }
        catch {
            return name;
        }
    }
    /**
     * Gets the type of the argument.
     */
    static getObjectType(value) {
        const objectType = Object.prototype.toString.call(value);
        return objectType.match(/\[object (\w+)]/)[1].toLowerCase();
    }
    /**
     * Checks whether the value is POJO (e.g. `{ foo: 'bar' }`, and not instance of `Foo`)
     */
    static isPlainObject(value) {
        return (value !== null
            && typeof value === 'object'
            && typeof value.constructor === 'function'
            // eslint-disable-next-line no-prototype-builtins
            && (value.constructor.prototype.hasOwnProperty('isPrototypeOf') || Object.getPrototypeOf(value.constructor.prototype) === null))
            || (value && Object.getPrototypeOf(value) === null)
            || value instanceof enums_1.PlainObject;
    }
    /**
     * Executes the `cb` promise serially on every element of the `items` array and returns array of resolved values.
     */
    static async runSerial(items, cb) {
        const ret = [];
        for (const item of items) {
            ret.push(await cb(item));
        }
        return ret;
    }
    static isCollection(item, prop, type) {
        if (!item?.__collection) {
            return false;
        }
        return !(prop && type) || prop.reference === type;
    }
    static fileURLToPath(url) {
        // expose `fileURLToPath` on Utils so that it can be properly mocked in tests
        return (0, url_1.fileURLToPath)(url);
    }
    /**
     * Resolves and normalizes a series of path parts relative to each preceeding part.
     * If any part is a `file:` URL, it is converted to a local path. If any part is an
     * absolute path, it replaces preceeding paths (similar to `path.resolve` in NodeJS).
     * Trailing directory separators are removed, and all directory separators are converted
     * to POSIX-style separators (`/`).
     */
    static normalizePath(...parts) {
        let start = 0;
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if ((0, path_1.isAbsolute)(part)) {
                start = i;
            }
            else if (part.startsWith('file:')) {
                start = i;
                parts[i] = Utils.fileURLToPath(part);
            }
        }
        if (start > 0) {
            parts = parts.slice(start);
        }
        let path = parts.join('/').replace(/\\/g, '/').replace(/\/$/, '');
        path = (0, path_1.normalize)(path).replace(/\\/g, '/');
        return (path.match(/^[/.]|[a-zA-Z]:/) || path.startsWith('!')) ? path : './' + path;
    }
    /**
     * Determines the relative path between two paths. If either path is a `file:` URL,
     * it is converted to a local path.
     */
    static relativePath(path, relativeTo) {
        if (!path) {
            return path;
        }
        path = Utils.normalizePath(path);
        if (path.startsWith('.')) {
            return path;
        }
        path = (0, path_1.relative)(Utils.normalizePath(relativeTo), path);
        return Utils.normalizePath(path);
    }
    /**
     * Computes the absolute path to for the given path relative to the provided base directory.
     * If either `path` or `baseDir` are `file:` URLs, they are converted to local paths.
     */
    static absolutePath(path, baseDir = process.cwd()) {
        if (!path) {
            return Utils.normalizePath(baseDir);
        }
        if (!(0, path_1.isAbsolute)(path) && !path.startsWith('file://')) {
            path = baseDir + '/' + path;
        }
        return Utils.normalizePath(path);
    }
    static hash(data) {
        return (0, crypto_1.createHash)('md5').update(data).digest('hex');
    }
    static runIfNotEmpty(clause, data) {
        if (!Utils.isEmpty(data)) {
            clause();
        }
    }
    static defaultValue(prop, option, defaultValue) {
        prop[option] = option in prop ? prop[option] : defaultValue;
    }
    static findDuplicates(items) {
        return items.reduce((acc, v, i, arr) => {
            return arr.indexOf(v) !== i && acc.indexOf(v) === -1 ? acc.concat(v) : acc;
        }, []);
    }
    static randomInt(min, max) {
        return Math.round(Math.random() * (max - min)) + min;
    }
    static async pathExists(path, options = {}) {
        if (globby_1.default.hasMagic(path)) {
            const found = await (0, globby_1.default)(path, options);
            return found.length > 0;
        }
        return (0, fs_extra_1.pathExists)(path);
    }
    /**
     * Extracts all possible values of a TS enum. Works with both string and numeric enums.
     */
    static extractEnumValues(target) {
        const keys = Object.keys(target);
        const values = Object.values(target);
        const numeric = !!values.find(v => typeof v === 'number');
        const constEnum = values.length % 2 === 0 // const enum will have even number of items
            && values.slice(0, values.length / 2).every(v => typeof v === 'string') // first half are strings
            && values.slice(values.length / 2).every(v => typeof v === 'number') // second half are numbers
            && this.equals(keys, values.slice(values.length / 2).concat(values.slice(0, values.length / 2)).map(v => '' + v)); // and when swapped, it will match the keys
        if (numeric || constEnum) {
            return values.filter(val => !keys.includes(val));
        }
        return values;
    }
    static flatten(arrays) {
        return [].concat.apply([], arrays);
    }
    static isOperator(key, includeGroupOperators = true) {
        if (!includeGroupOperators) {
            return !!enums_1.QueryOperator[key];
        }
        return !!enums_1.GroupOperator[key] || !!enums_1.QueryOperator[key];
    }
    static isGroupOperator(key) {
        return !!enums_1.GroupOperator[key];
    }
    static getGlobalStorage(namespace) {
        const key = `mikro-orm-${namespace}`;
        global[key] = global[key] || {};
        return global[key];
    }
    /**
     * Require a module from a specific location
     * @param id The module to require
     * @param from Location to start the node resolution
     */
    static requireFrom(id, from) {
        if (!(0, path_1.extname)(from)) {
            from = (0, path_1.join)(from, '__fake.js');
        }
        return (0, module_1.createRequire)((0, path_1.resolve)(from))(id);
    }
    /**
     * Hack to keep dynamic imports even when compiling to CJS.
     * We can't use it always, as it would break ts-node.
     * @see https://github.com/microsoft/TypeScript/issues/43329#issuecomment-922544562
     */
    static async dynamicImport(id) {
        if (!process.env.MIKRO_ORM_DYNAMIC_IMPORTS) {
            return Promise.resolve().then(() => __importStar(require(id)));
        }
        /* istanbul ignore next */
        if ((0, os_1.platform)() === 'win32') {
            id = (0, url_1.pathToFileURL)(id).toString();
        }
        /* istanbul ignore next */
        return Function(`return import('${id}')`)();
    }
    static getORMVersion() {
        /* istanbul ignore next */
        try {
            // this works with ts-node during development (where we have `src` folder)
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            return require('../../package.json').version;
        }
        catch {
            // this works with node in production build (where we do not have the `src` folder)
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            return require('../package.json').version;
        }
    }
    /* istanbul ignore next */
    static createFunction(context, code) {
        try {
            return new Function(...context.keys(), `'use strict';\n` + code)(...context.values());
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.error(code);
            throw e;
        }
    }
    /* istanbul ignore next */
    static callCompiledFunction(fn, ...args) {
        try {
            return fn(...args);
        }
        catch (e) {
            if ([SyntaxError, TypeError, EvalError, ReferenceError].some(t => e instanceof t)) {
                const position = e.stack.match(/<anonymous>:(\d+):(\d+)/);
                let code = fn.toString();
                if (position) {
                    const lines = code.split('\n').map((line, idx) => {
                        if (idx === +position[1] - 4) {
                            return '> ' + line;
                        }
                        return '  ' + line;
                    });
                    lines.splice(+position[1] - 3, 0, ' '.repeat(+position[2] - 4) + '^');
                    code = lines.join('\n');
                }
                // eslint-disable-next-line no-console
                console.error(`JIT runtime error: ${e.message}\n\n${code}`);
            }
            throw e;
        }
    }
    /**
     * @see https://github.com/mikro-orm/mikro-orm/issues/840
     */
    static propertyDecoratorReturnValue() {
        if (process.env.BABEL_DECORATORS_COMPAT) {
            return {};
        }
    }
    static unwrapProperty(entity, meta, prop, payload = false) {
        let p = prop;
        const path = [];
        function isObjectProperty(prop) {
            return prop.embedded ? prop.object || prop.array || isObjectProperty(meta.properties[prop.embedded[0]]) : prop.object || !!prop.array;
        }
        if (!isObjectProperty(prop) && !prop.embedded) {
            return entity[prop.name] != null ? [[entity[prop.name], []]] : [];
        }
        while (p.embedded) {
            const child = meta.properties[p.embedded[0]];
            if (payload && !child.object && !child.array) {
                break;
            }
            path.shift();
            path.unshift(p.embedded[0], p.embedded[1]);
            p = child;
        }
        const ret = [];
        const follow = (t, idx = 0, i = []) => {
            const k = path[idx];
            if (Array.isArray(t)) {
                return t.forEach((t, ii) => follow(t, idx, [...i, ii]));
            }
            if (t == null) {
                return;
            }
            const target = t[k];
            if (path[++idx]) {
                follow(target, idx, i);
            }
            else if (target != null) {
                ret.push([target, i]);
            }
        };
        follow(entity);
        return ret;
    }
    static setPayloadProperty(entity, meta, prop, value, idx = []) {
        function isObjectProperty(prop) {
            return prop.embedded ? prop.object || prop.array || isObjectProperty(meta.properties[prop.embedded[0]]) : prop.object || !!prop.array;
        }
        if (!isObjectProperty(prop)) {
            entity[prop.name] = value;
            return;
        }
        let target = entity;
        let p = prop;
        const path = [];
        while (p.embedded) {
            path.shift();
            path.unshift(p.embedded[0], p.embedded[1]);
            const prev = p;
            p = meta.properties[p.embedded[0]];
            if (!p.object) {
                path.shift();
                path[0] = prev.name;
                break;
            }
        }
        let j = 0;
        path.forEach((k, i) => {
            if (i === path.length - 1) {
                if (Array.isArray(target)) {
                    target[idx[j++]][k] = value;
                }
                else {
                    target[k] = value;
                }
            }
            else {
                if (Array.isArray(target)) {
                    target = target[idx[j++]][k];
                }
                else {
                    target = target[k];
                }
            }
        });
    }
    static tryRequire({ module, from, allowError, warning }) {
        allowError ?? (allowError = `Cannot find module '${module}'`);
        from ?? (from = process.cwd());
        try {
            return Utils.requireFrom(module, from);
        }
        catch (err) {
            if (err.message.includes(allowError)) {
                // eslint-disable-next-line no-console
                console.warn(warning);
                return undefined;
            }
            throw err;
        }
    }
}
exports.Utils = Utils;
Utils.PK_SEPARATOR = '~~~';
