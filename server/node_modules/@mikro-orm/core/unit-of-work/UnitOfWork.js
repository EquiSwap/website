"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnitOfWork = void 0;
const entity_1 = require("../entity");
const ChangeSet_1 = require("./ChangeSet");
const ChangeSetComputer_1 = require("./ChangeSetComputer");
const ChangeSetPersister_1 = require("./ChangeSetPersister");
const CommitOrderCalculator_1 = require("./CommitOrderCalculator");
const Utils_1 = require("../utils/Utils");
const enums_1 = require("../enums");
const errors_1 = require("../errors");
const events_1 = require("../events");
const IdentityMap_1 = require("./IdentityMap");
class UnitOfWork {
    constructor(em) {
        this.em = em;
        /** map of references to managed entities */
        this.identityMap = new IdentityMap_1.IdentityMap();
        this.persistStack = new Set();
        this.removeStack = new Set();
        this.orphanRemoveStack = new Set();
        this.changeSets = new Map();
        this.collectionUpdates = new Set();
        this.extraUpdates = new Set();
        this.metadata = this.em.getMetadata();
        this.platform = this.em.getPlatform();
        this.eventManager = this.em.getEventManager();
        this.comparator = this.em.getComparator();
        this.changeSetComputer = new ChangeSetComputer_1.ChangeSetComputer(this.em.getValidator(), this.collectionUpdates, this.metadata, this.platform, this.em.config);
        this.changeSetPersister = new ChangeSetPersister_1.ChangeSetPersister(this.em.getDriver(), this.metadata, this.em.config.getHydrator(this.metadata), this.em.getEntityFactory(), this.em.getValidator(), this.em.config);
        this.queuedActions = new Set();
        this.loadedEntities = new Set();
        this.flushQueue = [];
        this.working = false;
        this.insideHooks = false;
    }
    merge(entity, visited) {
        const wrapped = entity.__helper;
        wrapped.__em = this.em;
        wrapped.__populated = true;
        if (!wrapped.hasPrimaryKey()) {
            return;
        }
        // skip new entities that could be linked from already persisted entity
        // that is being re-fetched (but allow calling `merge(e)` explicitly for those)
        if (!wrapped.__managed && visited) {
            return;
        }
        this.identityMap.store(entity);
        wrapped.__populated = true;
        // if visited is available, we are cascading, and need to be careful when resetting the entity data
        // as there can be some entity with already changed state that is not yet flushed
        if (wrapped.__initialized && (!visited || !wrapped.__originalEntityData)) {
            wrapped.__originalEntityData = this.comparator.prepareEntity(entity);
            this.queuedActions.delete(wrapped.__meta.className);
            wrapped.__touched = false;
        }
        this.cascade(entity, enums_1.Cascade.MERGE, visited ?? new Set());
    }
    /**
     * @internal
     */
    registerManaged(entity, data, options) {
        this.identityMap.store(entity);
        if (options?.newEntity) {
            return entity;
        }
        if (options?.loaded && entity.__helper.__initialized && !entity.__helper.__onLoadFired) {
            this.loadedEntities.add(entity);
        }
        const helper = entity.__helper;
        helper.__em ?? (helper.__em = this.em);
        if (data && helper.__initialized && (options?.refresh || !helper.__originalEntityData)) {
            // we can't use the `data` directly here as it can contain fetch joined data, that can't be used for diffing the state
            helper.__originalEntityData = this.comparator.prepareEntity(entity);
            Object.keys(data).forEach(key => entity.__helper.__loadedProperties.add(key));
            this.queuedActions.delete(helper.__meta.className);
            helper.__touched = false;
        }
        return entity;
    }
    /**
     * @internal
     */
    async dispatchOnLoadEvent() {
        for (const entity of this.loadedEntities) {
            if (this.eventManager.hasListeners(enums_1.EventType.onLoad, entity.__meta)) {
                await this.eventManager.dispatchEvent(enums_1.EventType.onLoad, { entity, em: this.em });
                entity.__helper.__onLoadFired = true;
            }
        }
        this.loadedEntities.clear();
    }
    /**
     * Returns entity from the identity map. For composite keys, you need to pass an array of PKs in the same order as they are defined in `meta.primaryKeys`.
     */
    getById(entityName, id, schema) {
        if (id == null || (Array.isArray(id) && id.length === 0)) {
            return undefined;
        }
        const meta = this.metadata.find(entityName).root;
        let hash = Array.isArray(id) ? Utils_1.Utils.getPrimaryKeyHash(id) : '' + id;
        schema ?? (schema = meta.schema);
        if (schema) {
            hash = `${schema}:${hash}`;
        }
        return this.identityMap.getByHash(meta, hash);
    }
    tryGetById(entityName, where, schema, strict = true) {
        const pk = Utils_1.Utils.extractPK(where, this.metadata.find(entityName), strict);
        if (!pk) {
            return null;
        }
        return this.getById(entityName, pk, schema);
    }
    /**
     * Returns map of all managed entities.
     */
    getIdentityMap() {
        return this.identityMap;
    }
    /**
     * Returns stored snapshot of entity state that is used for change set computation.
     */
    getOriginalEntityData(entity) {
        if (!entity) {
            return this.identityMap.values().map(e => {
                return e.__helper.__originalEntityData;
            });
        }
        return entity.__helper.__originalEntityData;
    }
    getPersistStack() {
        return this.persistStack;
    }
    getRemoveStack() {
        return this.removeStack;
    }
    getChangeSets() {
        return [...this.changeSets.values()];
    }
    getCollectionUpdates() {
        return [...this.collectionUpdates];
    }
    getExtraUpdates() {
        return this.extraUpdates;
    }
    shouldAutoFlush(meta) {
        if (this.insideHooks) {
            return false;
        }
        if (this.queuedActions.has(meta.className) || this.queuedActions.has(meta.root.className)) {
            return true;
        }
        for (const entity of this.identityMap.getStore(meta).values()) {
            if (entity.__helper.__initialized && entity.__helper.isTouched()) {
                return true;
            }
        }
        return false;
    }
    clearActionsQueue() {
        this.queuedActions.clear();
    }
    computeChangeSet(entity) {
        const cs = this.changeSetComputer.computeChangeSet(entity);
        if (!cs || this.checkUniqueProps(cs)) {
            return;
        }
        this.initIdentifier(entity);
        this.checkOrphanRemoval(cs);
        this.changeSets.set(entity, cs);
        this.persistStack.delete(entity);
        this.queuedActions.delete(cs.name);
        entity.__helper.__originalEntityData = this.comparator.prepareEntity(entity);
        entity.__helper.__touched = false;
    }
    recomputeSingleChangeSet(entity) {
        const changeSet = this.changeSets.get(entity);
        if (!changeSet) {
            return;
        }
        const cs = this.changeSetComputer.computeChangeSet(entity);
        /* istanbul ignore else */
        if (cs && !this.checkUniqueProps(changeSet)) {
            this.checkOrphanRemoval(cs);
            Object.assign(changeSet.payload, cs.payload);
            entity.__helper.__originalEntityData = this.comparator.prepareEntity(entity);
            entity.__helper.__touched = false;
        }
    }
    persist(entity, visited, options = {}) {
        if (options.checkRemoveStack && (this.removeStack.has(entity))) {
            return;
        }
        this.persistStack.add(entity);
        this.queuedActions.add(entity.__meta.className);
        this.removeStack.delete(entity);
        if (options.cascade ?? true) {
            this.cascade(entity, enums_1.Cascade.PERSIST, visited, options);
        }
    }
    remove(entity, visited, options = {}) {
        this.removeStack.add(entity);
        this.queuedActions.add(entity.__meta.className);
        this.persistStack.delete(entity);
        // remove from referencing relations (but don't remove FKs as PKs)
        for (const prop of entity.__meta.bidirectionalRelations) {
            const inverseProp = prop.mappedBy || prop.inversedBy;
            const relation = entity_1.Reference.unwrapReference(entity[prop.name]);
            const prop2 = prop.targetMeta.properties[inverseProp];
            if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY && !prop2.primary && Utils_1.Utils.isCollection(relation)) {
                relation.getItems(false).forEach(item => delete item[inverseProp]);
                continue;
            }
            if (relation && Utils_1.Utils.isCollection(relation[inverseProp])) {
                relation[inverseProp].removeWithoutPropagation(entity);
            }
        }
        if (options.cascade ?? true) {
            this.cascade(entity, enums_1.Cascade.REMOVE, visited);
        }
    }
    async commit() {
        if (this.working) {
            if (this.insideHooks) {
                throw errors_1.ValidationError.cannotCommit();
            }
            return new Promise((resolve, reject) => {
                this.flushQueue.push(() => this.doCommit().then(resolve, reject));
            });
        }
        this.working = true;
        await this.doCommit();
        while (this.flushQueue.length) {
            await this.flushQueue.shift()();
        }
        this.working = false;
    }
    async doCommit() {
        const oldTx = this.em.getTransactionContext();
        try {
            await this.eventManager.dispatchEvent(enums_1.EventType.beforeFlush, { em: this.em, uow: this });
            this.computeChangeSets();
            await this.eventManager.dispatchEvent(enums_1.EventType.onFlush, { em: this.em, uow: this });
            // nothing to do, do not start transaction
            if (this.changeSets.size === 0 && this.collectionUpdates.size === 0 && this.extraUpdates.size === 0) {
                return void await this.eventManager.dispatchEvent(enums_1.EventType.afterFlush, { em: this.em, uow: this });
            }
            const groups = this.getChangeSetGroups();
            const platform = this.em.getPlatform();
            const runInTransaction = !this.em.isInTransaction() && platform.supportsTransactions() && this.em.config.get('implicitTransactions');
            if (runInTransaction) {
                await this.em.getConnection('write').transactional(trx => this.persistToDatabase(groups, trx), {
                    ctx: oldTx,
                    eventBroadcaster: new events_1.TransactionEventBroadcaster(this.em, this),
                });
            }
            else {
                await this.persistToDatabase(groups, this.em.getTransactionContext());
            }
            this.resetTransaction(oldTx);
            await this.eventManager.dispatchEvent(enums_1.EventType.afterFlush, { em: this.em, uow: this });
        }
        finally {
            this.postCommitCleanup();
            this.resetTransaction(oldTx);
        }
    }
    async lock(entity, options) {
        if (!this.getById(entity.constructor.name, entity.__helper.__primaryKeys, entity.__helper.__schema)) {
            throw errors_1.ValidationError.entityNotManaged(entity);
        }
        const meta = this.metadata.find(entity.constructor.name);
        if (options.lockMode === enums_1.LockMode.OPTIMISTIC) {
            await this.lockOptimistic(entity, meta, options.lockVersion);
        }
        else if (options.lockMode != null) {
            await this.lockPessimistic(entity, options);
        }
    }
    clear() {
        this.identityMap.clear();
        this.loadedEntities.clear();
        this.postCommitCleanup();
    }
    unsetIdentity(entity) {
        this.identityMap.delete(entity);
        const wrapped = entity.__helper;
        wrapped.__meta.bidirectionalRelations
            .map(prop => [prop.name, prop.mappedBy || prop.inversedBy])
            .forEach(([name, inverse]) => {
            const rel = entity_1.Reference.unwrapReference(entity[name]);
            // there is a value, and it is still a self-reference (e.g. not replaced by user manually)
            if (rel?.[inverse] && entity === rel?.[inverse]) {
                delete rel[inverse];
            }
        });
        delete wrapped.__identifier;
        delete wrapped.__originalEntityData;
        wrapped.__touched = false;
    }
    computeChangeSets() {
        this.changeSets.clear();
        const visited = new Set();
        for (const entity of this.removeStack) {
            this.cascade(entity, enums_1.Cascade.REMOVE, visited);
        }
        visited.clear();
        for (const entity of this.persistStack) {
            this.cascade(entity, enums_1.Cascade.PERSIST, visited, { checkRemoveStack: true });
        }
        for (const entity of this.identityMap) {
            if (!this.removeStack.has(entity) && !this.persistStack.has(entity) && !this.orphanRemoveStack.has(entity)) {
                this.persistStack.add(entity);
                this.cascade(entity, enums_1.Cascade.PERSIST, visited, { checkRemoveStack: true });
            }
        }
        visited.clear();
        for (const entity of this.persistStack) {
            this.findNewEntities(entity);
        }
        for (const entity of this.orphanRemoveStack) {
            this.removeStack.add(entity);
        }
        // Check insert stack if there are any entities matching something from delete stack. This can happen when recreating entities.
        const inserts = [];
        for (const cs of this.changeSets.values()) {
            if (cs.type === ChangeSet_1.ChangeSetType.CREATE) {
                inserts.push(cs);
            }
        }
        for (const entity of this.removeStack) {
            const deletePkHash = [entity.__helper.getSerializedPrimaryKey(), ...this.expandUniqueProps(entity)];
            let type = ChangeSet_1.ChangeSetType.DELETE;
            for (const cs of inserts) {
                if (deletePkHash.some(hash => hash === cs.getSerializedPrimaryKey() || this.expandUniqueProps(cs.entity).find(child => hash === child))) {
                    type = ChangeSet_1.ChangeSetType.DELETE_EARLY;
                }
            }
            this.changeSets.set(entity, new ChangeSet_1.ChangeSet(entity, type, {}, entity.__meta));
        }
    }
    scheduleExtraUpdate(changeSet, props) {
        if (props.length === 0) {
            return;
        }
        this.extraUpdates.add([changeSet.entity, props.map(p => p.name), props.map(p => changeSet.entity[p.name])]);
        props.forEach(p => delete changeSet.entity[p.name]);
        props.forEach(p => delete changeSet.payload[p.name]);
    }
    scheduleOrphanRemoval(entity, visited) {
        if (entity) {
            this.orphanRemoveStack.add(entity);
            this.queuedActions.add(entity.__meta.className);
            this.cascade(entity, enums_1.Cascade.SCHEDULE_ORPHAN_REMOVAL, visited);
        }
    }
    cancelOrphanRemoval(entity, visited) {
        this.orphanRemoveStack.delete(entity);
        this.cascade(entity, enums_1.Cascade.CANCEL_ORPHAN_REMOVAL, visited);
    }
    findNewEntities(entity, visited = new Set(), idx = 0) {
        if (visited.has(entity)) {
            return;
        }
        visited.add(entity);
        const wrapped = entity.__helper;
        if (!wrapped.__initialized || this.removeStack.has(entity) || this.orphanRemoveStack.has(entity)) {
            return;
        }
        this.initIdentifier(entity);
        for (const prop of entity.__meta.relations) {
            const targets = Utils_1.Utils.unwrapProperty(entity, entity.__meta, prop);
            targets.forEach(([target]) => {
                const reference = entity_1.Reference.unwrapReference(target);
                this.processReference(entity, prop, reference, visited, idx);
            });
        }
        const changeSet = this.changeSetComputer.computeChangeSet(entity);
        if (changeSet && !this.checkUniqueProps(changeSet)) {
            this.checkOrphanRemoval(changeSet);
            this.changeSets.set(entity, changeSet);
        }
    }
    checkUniqueProps(changeSet) {
        if (this.platform.allowsUniqueBatchUpdates() || changeSet.type !== ChangeSet_1.ChangeSetType.UPDATE) {
            return false;
        }
        // when changing a unique nullable property (or a 1:1 relation), we can't do it in a single query as it would cause unique constraint violations
        const uniqueProps = changeSet.entity.__meta.uniqueProps.filter(prop => prop.nullable && changeSet.payload[prop.name] != null);
        this.scheduleExtraUpdate(changeSet, uniqueProps);
        return changeSet.type === ChangeSet_1.ChangeSetType.UPDATE && !Utils_1.Utils.hasObjectKeys(changeSet.payload);
    }
    expandUniqueProps(entity) {
        return entity.__meta.uniqueProps.map(prop => {
            if (entity[prop.name]) {
                return prop.reference === enums_1.ReferenceType.SCALAR ? entity[prop.name] : entity[prop.name].__helper.getSerializedPrimaryKey();
            }
            return undefined;
        }).filter(i => i);
    }
    checkOrphanRemoval(changeSet) {
        const meta = this.metadata.find(changeSet.name);
        const props = meta.relations.filter(prop => prop.reference === enums_1.ReferenceType.ONE_TO_ONE);
        for (const prop of props) {
            // check diff, if we had a value on 1:1 before and now it changed (nulled or replaced), we need to trigger orphan removal
            const wrapped = changeSet.entity.__helper;
            const data = wrapped.__originalEntityData;
            if (prop.orphanRemoval && data && data[prop.name] && prop.name in changeSet.payload) {
                const orphan = this.getById(prop.type, data[prop.name], wrapped.__schema);
                this.scheduleOrphanRemoval(orphan);
            }
        }
    }
    initIdentifier(entity) {
        const wrapped = entity.__helper;
        if (wrapped.__identifier || wrapped.hasPrimaryKey()) {
            return;
        }
        const pk = wrapped.__meta.getPrimaryProps()[0];
        if (pk.reference === enums_1.ReferenceType.SCALAR) {
            wrapped.__identifier = new entity_1.EntityIdentifier();
        }
        else {
            this.initIdentifier(entity[pk.name]);
            wrapped.__identifier = entity[pk.name].__helper?.__identifier;
        }
    }
    processReference(parent, prop, reference, visited, idx) {
        const isToOne = prop.reference === enums_1.ReferenceType.MANY_TO_ONE || prop.reference === enums_1.ReferenceType.ONE_TO_ONE;
        if (isToOne && Utils_1.Utils.isEntity(reference)) {
            return this.processToOneReference(reference, visited, idx);
        }
        if (Utils_1.Utils.isCollection(reference, prop, enums_1.ReferenceType.MANY_TO_MANY) && reference.isDirty()) {
            this.processToManyReference(reference, visited, parent, prop);
        }
    }
    processToOneReference(reference, visited, idx) {
        if (!reference.__helper.__managed) {
            this.findNewEntities(reference, visited, idx);
        }
    }
    processToManyReference(collection, visited, parent, prop) {
        if (this.isCollectionSelfReferenced(collection, visited)) {
            this.extraUpdates.add([parent, prop.name, collection]);
            parent[prop.name] = new entity_1.Collection(parent);
            return;
        }
        collection.getItems(false)
            .filter(item => !item.__helper.__originalEntityData)
            .forEach(item => {
            var _a;
            // propagate schema from parent
            (_a = item.__helper).__schema ?? (_a.__schema = collection.owner.__helper.__schema);
            this.findNewEntities(item, visited);
        });
    }
    async runHooks(type, changeSet, sync = false) {
        const hasListeners = this.eventManager.hasListeners(type, changeSet.entity.__meta);
        if (!hasListeners) {
            return;
        }
        this.insideHooks = true;
        if (!sync) {
            await this.eventManager.dispatchEvent(type, { entity: changeSet.entity, em: this.em, changeSet });
            this.insideHooks = false;
            return;
        }
        const copy = this.comparator.prepareEntity(changeSet.entity);
        await this.eventManager.dispatchEvent(type, { entity: changeSet.entity, em: this.em, changeSet });
        const current = this.comparator.prepareEntity(changeSet.entity);
        const diff = this.comparator.diffEntities(changeSet.name, copy, current);
        Object.assign(changeSet.payload, diff);
        const wrapped = changeSet.entity.__helper;
        if (wrapped.__identifier && diff[wrapped.__meta.primaryKeys[0]]) {
            wrapped.__identifier.setValue(diff[wrapped.__meta.primaryKeys[0]]);
        }
        this.insideHooks = false;
    }
    postCommitCleanup() {
        this.persistStack.clear();
        this.removeStack.clear();
        this.orphanRemoveStack.clear();
        this.changeSets.clear();
        this.collectionUpdates.clear();
        this.extraUpdates.clear();
        this.queuedActions.clear();
        this.working = false;
        this.insideHooks = false;
    }
    cascade(entity, type, visited = new Set(), options = {}) {
        if (visited.has(entity)) {
            return;
        }
        visited.add(entity);
        switch (type) {
            case enums_1.Cascade.PERSIST:
                this.persist(entity, visited, options);
                break;
            case enums_1.Cascade.MERGE:
                this.merge(entity, visited);
                break;
            case enums_1.Cascade.REMOVE:
                this.remove(entity, visited, options);
                break;
            case enums_1.Cascade.SCHEDULE_ORPHAN_REMOVAL:
                this.scheduleOrphanRemoval(entity, visited);
                break;
            case enums_1.Cascade.CANCEL_ORPHAN_REMOVAL:
                this.cancelOrphanRemoval(entity, visited);
                break;
        }
        for (const prop of entity.__meta.relations) {
            this.cascadeReference(entity, prop, type, visited, options);
        }
    }
    cascadeReference(entity, prop, type, visited, options) {
        this.fixMissingReference(entity, prop);
        if (!this.shouldCascade(prop, type)) {
            return;
        }
        const reference = entity_1.Reference.unwrapReference(entity[prop.name]);
        if ([enums_1.ReferenceType.MANY_TO_ONE, enums_1.ReferenceType.ONE_TO_ONE].includes(prop.reference) && Utils_1.Utils.isEntity(reference)) {
            return this.cascade(reference, type, visited, options);
        }
        const collection = reference;
        const requireFullyInitialized = type === enums_1.Cascade.PERSIST; // only cascade persist needs fully initialized items
        if ([enums_1.ReferenceType.ONE_TO_MANY, enums_1.ReferenceType.MANY_TO_MANY].includes(prop.reference) && collection) {
            if (type === enums_1.Cascade.MERGE && collection.isInitialized()) {
                collection.populated();
            }
            collection
                .getItems(false)
                .filter(item => !requireFullyInitialized || item.__helper.__initialized)
                .forEach(item => this.cascade(item, type, visited, options));
        }
    }
    isCollectionSelfReferenced(collection, visited) {
        const filtered = collection.getItems(false).filter(item => !item.__helper.__originalEntityData);
        return filtered.some(items => visited.has(items));
    }
    shouldCascade(prop, type) {
        if ([enums_1.Cascade.REMOVE, enums_1.Cascade.SCHEDULE_ORPHAN_REMOVAL, enums_1.Cascade.CANCEL_ORPHAN_REMOVAL, enums_1.Cascade.ALL].includes(type) && prop.orphanRemoval) {
            return true;
        }
        // ignore user settings for merge, it is kept only for back compatibility, this should have never been configurable
        if (type === enums_1.Cascade.MERGE) {
            return true;
        }
        return prop.cascade && (prop.cascade.includes(type) || prop.cascade.includes(enums_1.Cascade.ALL));
    }
    async lockPessimistic(entity, options) {
        if (!this.em.isInTransaction()) {
            throw errors_1.ValidationError.transactionRequired();
        }
        await this.em.getDriver().lockPessimistic(entity, { ctx: this.em.getTransactionContext(), ...options });
    }
    async lockOptimistic(entity, meta, version) {
        if (!meta.versionProperty) {
            throw errors_1.OptimisticLockError.notVersioned(meta);
        }
        if (!Utils_1.Utils.isDefined(version)) {
            return;
        }
        const wrapped = entity.__helper;
        if (!wrapped.__initialized) {
            await wrapped.init();
        }
        const previousVersion = entity[meta.versionProperty];
        if (previousVersion !== version) {
            throw errors_1.OptimisticLockError.lockFailedVersionMismatch(entity, version, previousVersion);
        }
    }
    fixMissingReference(entity, prop) {
        const reference = entity_1.Reference.unwrapReference(entity[prop.name]);
        if ([enums_1.ReferenceType.MANY_TO_ONE, enums_1.ReferenceType.ONE_TO_ONE].includes(prop.reference) && reference && !prop.mapToPk) {
            if (!Utils_1.Utils.isEntity(reference)) {
                entity[prop.name] = this.em.getReference(prop.type, reference, { wrapped: !!prop.wrappedReference });
            }
            else if (!reference.__helper.__initialized && !reference.__helper.__em) {
                const pk = reference.__helper.getSerializedPrimaryKey();
                entity[prop.name] = this.em.getReference(prop.type, pk, { wrapped: !!prop.wrappedReference });
            }
        }
        const isCollection = [enums_1.ReferenceType.ONE_TO_MANY, enums_1.ReferenceType.MANY_TO_MANY].includes(prop.reference);
        if (isCollection && Array.isArray(reference)) {
            const collection = new entity_1.Collection(entity);
            entity[prop.name] = collection;
            collection.set(reference);
        }
    }
    async persistToDatabase(groups, ctx) {
        if (ctx) {
            this.em.setTransactionContext(ctx);
        }
        const commitOrder = this.getCommitOrder();
        const commitOrderReversed = [...commitOrder].reverse();
        // 1. early delete - when we recreate entity in the same UoW, we need to issue those delete queries before inserts
        for (const name of commitOrderReversed) {
            await this.commitDeleteChangeSets(groups[ChangeSet_1.ChangeSetType.DELETE_EARLY].get(name) ?? [], ctx);
        }
        // 2. create
        for (const name of commitOrder) {
            await this.commitCreateChangeSets(groups[ChangeSet_1.ChangeSetType.CREATE].get(name) ?? [], ctx);
        }
        // 3. update
        for (const name of commitOrder) {
            await this.commitUpdateChangeSets(groups[ChangeSet_1.ChangeSetType.UPDATE].get(name) ?? [], ctx);
        }
        // 4. extra updates
        const extraUpdates = [];
        for (const extraUpdate of this.extraUpdates) {
            if (Array.isArray(extraUpdate[1])) {
                extraUpdate[1].forEach((p, i) => extraUpdate[0][p] = extraUpdate[2][i]);
            }
            else {
                extraUpdate[0][extraUpdate[1]] = extraUpdate[2];
            }
            const changeSet = this.changeSetComputer.computeChangeSet(extraUpdate[0]);
            if (changeSet) {
                extraUpdates.push(changeSet);
            }
        }
        await this.commitUpdateChangeSets(extraUpdates, ctx, false);
        // 5. collection updates
        for (const coll of this.collectionUpdates) {
            await this.em.getDriver().syncCollection(coll, { ctx });
            coll.takeSnapshot();
        }
        // 6. delete - entity deletions need to be in reverse commit order
        for (const name of commitOrderReversed) {
            await this.commitDeleteChangeSets(groups[ChangeSet_1.ChangeSetType.DELETE].get(name) ?? [], ctx);
        }
        // 7. take snapshots of all persisted collections
        const visited = new Set();
        for (const changeSet of this.changeSets.values()) {
            this.takeCollectionSnapshots(changeSet.entity, visited);
        }
    }
    async commitCreateChangeSets(changeSets, ctx) {
        if (changeSets.length === 0) {
            return;
        }
        const meta = changeSets[0].entity.__meta;
        const props = meta.relations.filter(prop => {
            return (prop.reference === enums_1.ReferenceType.ONE_TO_ONE && prop.owner) || prop.reference === enums_1.ReferenceType.MANY_TO_ONE;
        });
        for (const changeSet of changeSets) {
            this.findExtraUpdates(changeSet, props);
            await this.runHooks(enums_1.EventType.beforeCreate, changeSet, true);
        }
        await this.changeSetPersister.executeInserts(changeSets, { ctx });
        for (const changeSet of changeSets) {
            this.registerManaged(changeSet.entity, changeSet.payload, { refresh: true });
            await this.runHooks(enums_1.EventType.afterCreate, changeSet);
        }
    }
    findExtraUpdates(changeSet, props) {
        for (const prop of props) {
            if (!changeSet.entity[prop.name]) {
                continue;
            }
            const cs = this.changeSets.get(entity_1.Reference.unwrapReference(changeSet.entity[prop.name]));
            const isScheduledForInsert = cs && cs.type === ChangeSet_1.ChangeSetType.CREATE && !cs.persisted;
            if (isScheduledForInsert) {
                this.scheduleExtraUpdate(changeSet, [prop]);
            }
        }
    }
    async commitUpdateChangeSets(changeSets, ctx, batched = true) {
        if (changeSets.length === 0) {
            return;
        }
        for (const changeSet of changeSets) {
            await this.runHooks(enums_1.EventType.beforeUpdate, changeSet, true);
        }
        await this.changeSetPersister.executeUpdates(changeSets, batched, { ctx });
        for (const changeSet of changeSets) {
            changeSet.entity.__helper.__originalEntityData = this.comparator.prepareEntity(changeSet.entity);
            changeSet.entity.__helper.__touched = false;
            await this.runHooks(enums_1.EventType.afterUpdate, changeSet);
        }
    }
    async commitDeleteChangeSets(changeSets, ctx) {
        if (changeSets.length === 0) {
            return;
        }
        for (const changeSet of changeSets) {
            await this.runHooks(enums_1.EventType.beforeDelete, changeSet, true);
        }
        await this.changeSetPersister.executeDeletes(changeSets, { ctx });
        for (const changeSet of changeSets) {
            this.unsetIdentity(changeSet.entity);
            await this.runHooks(enums_1.EventType.afterDelete, changeSet);
        }
    }
    /**
     * Orders change sets so FK constrains are maintained, ensures stable order (needed for node < 11)
     */
    getChangeSetGroups() {
        const groups = {
            [ChangeSet_1.ChangeSetType.CREATE]: new Map(),
            [ChangeSet_1.ChangeSetType.UPDATE]: new Map(),
            [ChangeSet_1.ChangeSetType.DELETE]: new Map(),
            [ChangeSet_1.ChangeSetType.DELETE_EARLY]: new Map(),
        };
        this.changeSets.forEach(cs => {
            const group = groups[cs.type];
            const classGroup = group.get(cs.rootName) ?? [];
            classGroup.push(cs);
            if (!group.has(cs.rootName)) {
                group.set(cs.rootName, classGroup);
            }
        });
        return groups;
    }
    getCommitOrder() {
        const calc = new CommitOrderCalculator_1.CommitOrderCalculator();
        const set = new Set();
        this.changeSets.forEach(cs => set.add(cs.rootName));
        set.forEach(entityName => calc.addNode(entityName));
        for (const entityName of set) {
            for (const prop of this.metadata.find(entityName).props) {
                calc.discoverProperty(prop, entityName);
            }
        }
        return calc.sort();
    }
    resetTransaction(oldTx) {
        if (oldTx) {
            this.em.setTransactionContext(oldTx);
        }
        else {
            this.em.resetTransactionContext();
        }
    }
    /**
     * Takes snapshots of all processed collections
     */
    takeCollectionSnapshots(entity, visited) {
        if (visited.has(entity)) {
            return;
        }
        visited.add(entity);
        entity.__meta?.relations.forEach(prop => {
            const value = entity[prop.name];
            if (Utils_1.Utils.isCollection(value)) {
                value.takeSnapshot();
            }
            // cascade to m:1 relations as we need to snapshot the 1:m inverse side (for `removeAll()` with orphan removal)
            if (prop.reference === enums_1.ReferenceType.MANY_TO_ONE && value) {
                this.takeCollectionSnapshots(entity_1.Reference.unwrapReference(value), visited);
            }
        });
    }
}
exports.UnitOfWork = UnitOfWork;
