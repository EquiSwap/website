"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeSetPersister = void 0;
const entity_1 = require("../entity");
const ChangeSet_1 = require("./ChangeSet");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
const enums_1 = require("../enums");
class ChangeSetPersister {
    constructor(driver, metadata, hydrator, factory, validator, config) {
        this.driver = driver;
        this.metadata = metadata;
        this.hydrator = hydrator;
        this.factory = factory;
        this.validator = validator;
        this.config = config;
        this.platform = this.driver.getPlatform();
    }
    async executeInserts(changeSets, options, withSchema) {
        if (!withSchema) {
            return this.runForEachSchema(changeSets, 'executeInserts', options);
        }
        const meta = this.metadata.find(changeSets[0].name);
        changeSets.forEach(changeSet => this.processProperties(changeSet));
        if (changeSets.length > 1 && this.config.get('useBatchInserts', this.platform.usesBatchInserts())) {
            return this.persistNewEntities(meta, changeSets, options);
        }
        for (const changeSet of changeSets) {
            await this.persistNewEntity(meta, changeSet, options);
        }
    }
    async executeUpdates(changeSets, batched, options, withSchema) {
        if (!withSchema) {
            return this.runForEachSchema(changeSets, 'executeUpdates', options, batched);
        }
        const meta = this.metadata.find(changeSets[0].name);
        changeSets.forEach(changeSet => this.processProperties(changeSet));
        if (batched && changeSets.length > 1 && this.config.get('useBatchUpdates', this.platform.usesBatchUpdates())) {
            return this.persistManagedEntities(meta, changeSets, options);
        }
        for (const changeSet of changeSets) {
            await this.persistManagedEntity(changeSet, options);
        }
    }
    async executeDeletes(changeSets, options, withSchema) {
        if (!withSchema) {
            return this.runForEachSchema(changeSets, 'executeDeletes', options);
        }
        const size = this.config.get('batchSize');
        const meta = changeSets[0].entity.__meta;
        const pk = utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
        for (let i = 0; i < changeSets.length; i += size) {
            const chunk = changeSets.slice(i, i + size);
            const pks = chunk.map(cs => cs.getPrimaryKey());
            options = this.propagateSchemaFromMetadata(meta, options);
            await this.driver.nativeDelete(meta.className, { [pk]: { $in: pks } }, options);
        }
    }
    async runForEachSchema(changeSets, method, options, ...args) {
        const groups = new Map();
        changeSets.forEach(cs => {
            const group = groups.get(cs.schema) ?? [];
            group.push(cs);
            groups.set(cs.schema, group);
        });
        for (const [key, group] of groups.entries()) {
            options = { ...options, schema: key };
            await this[method](group, ...args, options, true);
        }
    }
    processProperties(changeSet) {
        const meta = this.metadata.find(changeSet.name);
        for (const prop of meta.props) {
            this.processProperty(changeSet, prop);
        }
        if (changeSet.type === ChangeSet_1.ChangeSetType.CREATE && this.config.get('validateRequired')) {
            this.validator.validateRequired(changeSet.entity);
        }
    }
    async persistNewEntity(meta, changeSet, options) {
        const wrapped = changeSet.entity.__helper;
        options = this.propagateSchemaFromMetadata(meta, options, {
            convertCustomTypes: false,
        });
        const res = await this.driver.nativeInsert(changeSet.name, changeSet.payload, options);
        if (!wrapped.hasPrimaryKey()) {
            this.mapPrimaryKey(meta, res.insertId, changeSet);
        }
        this.mapReturnedValues(changeSet, res, meta);
        this.markAsPopulated(changeSet, meta);
        wrapped.__initialized = true;
        wrapped.__managed = true;
        if (!this.platform.usesReturningStatement()) {
            await this.reloadVersionValues(meta, [changeSet], options);
        }
        changeSet.persisted = true;
    }
    async persistNewEntities(meta, changeSets, options) {
        const size = this.config.get('batchSize');
        for (let i = 0; i < changeSets.length; i += size) {
            const chunk = changeSets.slice(i, i + size);
            await this.persistNewEntitiesBatch(meta, chunk, options);
            if (!this.platform.usesReturningStatement()) {
                await this.reloadVersionValues(meta, chunk, options);
            }
        }
    }
    propagateSchemaFromMetadata(meta, options, additionalOptions) {
        return {
            ...options,
            ...additionalOptions,
            schema: options?.schema ?? meta.schema,
        };
    }
    async persistNewEntitiesBatch(meta, changeSets, options) {
        options = this.propagateSchemaFromMetadata(meta, options, {
            convertCustomTypes: false,
            processCollections: false,
        });
        const res = await this.driver.nativeInsertMany(meta.className, changeSets.map(cs => cs.payload), options);
        for (let i = 0; i < changeSets.length; i++) {
            const changeSet = changeSets[i];
            const wrapped = changeSet.entity.__helper;
            if (!wrapped.hasPrimaryKey()) {
                const field = meta.getPrimaryProps()[0].fieldNames[0];
                this.mapPrimaryKey(meta, res.rows[i][field], changeSet);
            }
            this.mapReturnedValues(changeSet, res, meta);
            this.markAsPopulated(changeSet, meta);
            wrapped.__initialized = true;
            wrapped.__managed = true;
            changeSet.persisted = true;
        }
    }
    async persistManagedEntity(changeSet, options) {
        const meta = this.metadata.find(changeSet.name);
        const res = await this.updateEntity(meta, changeSet, options);
        this.checkOptimisticLock(meta, changeSet, res);
        await this.reloadVersionValues(meta, [changeSet], options);
        changeSet.persisted = true;
    }
    async persistManagedEntities(meta, changeSets, options) {
        const size = this.config.get('batchSize');
        for (let i = 0; i < changeSets.length; i += size) {
            const chunk = changeSets.slice(i, i + size);
            await this.persistManagedEntitiesBatch(meta, chunk, options);
            await this.reloadVersionValues(meta, chunk, options);
        }
    }
    checkConcurrencyKeys(meta, changeSet, cond) {
        const tmp = [];
        cond = utils_1.Utils.isPlainObject(cond) ? cond : { [meta.primaryKeys[0]]: cond };
        for (const key of meta.concurrencyCheckKeys) {
            cond[key] = changeSet.originalEntity[key];
            if (changeSet.payload[key]) {
                tmp.push(key);
            }
        }
        if (tmp.length === 0 && meta.concurrencyCheckKeys.size > 0) {
            throw errors_1.OptimisticLockError.lockFailed(changeSet.entity);
        }
    }
    async persistManagedEntitiesBatch(meta, changeSets, options) {
        await this.checkOptimisticLocks(meta, changeSets, options);
        options = this.propagateSchemaFromMetadata(meta, options, {
            convertCustomTypes: false,
            processCollections: false,
        });
        const cond = changeSets.map(cs => cs.getPrimaryKey());
        changeSets.forEach((changeSet, idx) => {
            this.checkConcurrencyKeys(meta, changeSet, cond[idx]);
        });
        await this.driver.nativeUpdateMany(meta.className, cond, changeSets.map(cs => cs.payload), options);
        changeSets.forEach(cs => cs.persisted = true);
    }
    mapPrimaryKey(meta, value, changeSet) {
        const prop = meta.properties[meta.primaryKeys[0]];
        const insertId = prop.customType ? prop.customType.convertToJSValue(value, this.platform) : value;
        const wrapped = changeSet.entity.__helper;
        if (!wrapped.hasPrimaryKey()) {
            wrapped.setPrimaryKey(insertId);
        }
        // some drivers might be returning bigint PKs as numbers when the number is small enough,
        // but we need to have it as string so comparison works in change set tracking, so instead
        // of using the raw value from db, we convert it back to the db value explicitly
        value = prop.customType ? prop.customType.convertToDatabaseValue(insertId, this.platform) : value;
        changeSet.payload[wrapped.__meta.primaryKeys[0]] = value;
        wrapped.__identifier.setValue(value);
    }
    /**
     * Sets populate flag to new entities so they are serialized like if they were loaded from the db
     */
    markAsPopulated(changeSet, meta) {
        changeSet.entity.__helper.__schema = this.driver.getSchemaName(meta, changeSet);
        if (!this.config.get('populateAfterFlush')) {
            return;
        }
        changeSet.entity.__helper.populated();
        meta.relations.forEach(prop => {
            const value = changeSet.entity[prop.name];
            if (utils_1.Utils.isEntity(value, true)) {
                value.__helper.populated();
            }
            else if (utils_1.Utils.isCollection(value)) {
                value.populated();
            }
        });
    }
    async updateEntity(meta, changeSet, options) {
        options = this.propagateSchemaFromMetadata(meta, options, {
            convertCustomTypes: false,
        });
        if (meta.concurrencyCheckKeys.size === 0 && (!meta.versionProperty || !changeSet.entity[meta.versionProperty])) {
            return this.driver.nativeUpdate(changeSet.name, changeSet.getPrimaryKey(), changeSet.payload, options);
        }
        const cond = utils_1.Utils.getPrimaryKeyCond(changeSet.entity, meta.primaryKeys);
        if (meta.versionProperty) {
            cond[meta.versionProperty] = this.platform.quoteVersionValue(changeSet.entity[meta.versionProperty], meta.properties[meta.versionProperty]);
        }
        this.checkConcurrencyKeys(meta, changeSet, cond);
        return this.driver.nativeUpdate(changeSet.name, cond, changeSet.payload, options);
    }
    async checkOptimisticLocks(meta, changeSets, options) {
        if (meta.concurrencyCheckKeys.size === 0 && (!meta.versionProperty || changeSets.every(cs => !cs.entity[meta.versionProperty]))) {
            return;
        }
        const $or = changeSets.map(cs => {
            const cond = utils_1.Utils.getPrimaryKeyCond(cs.originalEntity, meta.primaryKeys.concat(...meta.concurrencyCheckKeys));
            if (meta.versionProperty) {
                cond[meta.versionProperty] = this.platform.quoteVersionValue(cs.entity[meta.versionProperty], meta.properties[meta.versionProperty]);
            }
            return cond;
        });
        const primaryKeys = meta.primaryKeys.concat(...meta.concurrencyCheckKeys);
        options = this.propagateSchemaFromMetadata(meta, options, {
            fields: primaryKeys,
        });
        const res = await this.driver.find(meta.className, { $or }, options);
        if (res.length !== changeSets.length) {
            const compare = (a, b, keys) => keys.every(k => a[k] === b[k]);
            const entity = changeSets.find(cs => {
                return !res.some(row => compare(utils_1.Utils.getPrimaryKeyCond(cs.entity, primaryKeys), row, primaryKeys));
            }).entity;
            throw errors_1.OptimisticLockError.lockFailed(entity);
        }
    }
    checkOptimisticLock(meta, changeSet, res) {
        if ((meta.versionProperty || meta.concurrencyCheckKeys.size > 0) && res && !res.affectedRows) {
            throw errors_1.OptimisticLockError.lockFailed(changeSet.entity);
        }
    }
    /**
     * This method also handles reloading of database default values for inserts, so we use
     * a single query in case of both versioning and default values is used.
     */
    async reloadVersionValues(meta, changeSets, options) {
        const reloadProps = meta.versionProperty ? [meta.properties[meta.versionProperty]] : [];
        if (changeSets[0].type === ChangeSet_1.ChangeSetType.CREATE) {
            // do not reload things that already had a runtime value
            reloadProps.push(...meta.props.filter(prop => prop.defaultRaw && prop.defaultRaw.toLowerCase() !== 'null' && changeSets[0].entity[prop.name] == null));
        }
        if (reloadProps.length === 0) {
            return;
        }
        const pk = utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
        const pks = changeSets.map(cs => cs.getPrimaryKey());
        options = this.propagateSchemaFromMetadata(meta, options, {
            fields: reloadProps.map(prop => prop.fieldNames[0]),
        });
        const data = await this.driver.find(meta.name, { [pk]: { $in: pks } }, options);
        const map = new Map();
        data.forEach(item => map.set(utils_1.Utils.getCompositeKeyHash(item, meta), item));
        for (const changeSet of changeSets) {
            const data = map.get(changeSet.entity.__helper.getSerializedPrimaryKey());
            this.hydrator.hydrate(changeSet.entity, meta, data, this.factory, 'returning', false, true);
        }
    }
    processProperty(changeSet, prop) {
        const meta = this.metadata.find(changeSet.name);
        const values = utils_1.Utils.unwrapProperty(changeSet.payload, meta, prop, true); // for object embeddables
        const value = changeSet.payload[prop.name]; // for inline embeddables
        if (prop.reference === enums_1.ReferenceType.MANY_TO_MANY && Array.isArray(value)) {
            changeSet.payload[prop.name] = value.map(val => val instanceof entity_1.EntityIdentifier ? val.getValue() : val);
        }
        if (value instanceof entity_1.EntityIdentifier) {
            utils_1.Utils.setPayloadProperty(changeSet.payload, meta, prop, value.getValue());
        }
        values.forEach(([value, indexes]) => {
            if (value instanceof entity_1.EntityIdentifier) {
                utils_1.Utils.setPayloadProperty(changeSet.payload, meta, prop, value.getValue(), indexes);
            }
        });
    }
    /**
     * Maps values returned via `returning` statement (postgres) or the inserted id (other sql drivers).
     * No need to handle composite keys here as they need to be set upfront.
     * We do need to map to the change set payload too, as it will be used in the originalEntityData for new entities.
     */
    mapReturnedValues(changeSet, res, meta) {
        if (this.platform.usesReturningStatement() && res.row && utils_1.Utils.hasObjectKeys(res.row)) {
            const data = meta.props.reduce((ret, prop) => {
                if (prop.primary && !changeSet.entity.__helper.hasPrimaryKey()) {
                    this.mapPrimaryKey(meta, res.row[prop.fieldNames[0]], changeSet);
                    return ret;
                }
                if (prop.fieldNames && res.row[prop.fieldNames[0]] != null && changeSet.entity[prop.name] == null) {
                    ret[prop.name] = changeSet.payload[prop.name] = res.row[prop.fieldNames[0]];
                }
                return ret;
            }, {});
            if (utils_1.Utils.hasObjectKeys(data)) {
                this.hydrator.hydrate(changeSet.entity, meta, data, this.factory, 'returning', false, true);
            }
        }
    }
}
exports.ChangeSetPersister = ChangeSetPersister;
