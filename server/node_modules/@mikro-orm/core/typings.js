"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityMetadata = exports.OptionalProps = exports.PrimaryKeyProp = exports.PrimaryKeyType = exports.EntityRepositoryType = void 0;
const enums_1 = require("./enums");
const Utils_1 = require("./utils/Utils");
const EntityComparator_1 = require("./utils/EntityComparator");
exports.EntityRepositoryType = Symbol('EntityRepositoryType');
exports.PrimaryKeyType = Symbol('PrimaryKeyType');
exports.PrimaryKeyProp = Symbol('PrimaryKeyProp');
exports.OptionalProps = Symbol('OptionalProps');
class EntityMetadata {
    constructor(meta = {}) {
        this.propertyOrder = new Map();
        this.properties = {};
        this.props = [];
        this.primaryKeys = [];
        this.filters = {};
        this.hooks = {};
        this.indexes = [];
        this.uniques = [];
        this.checks = [];
        this.concurrencyCheckKeys = new Set();
        Object.assign(this, meta);
    }
    addProperty(prop, sync = true) {
        this.properties[prop.name] = prop;
        this.propertyOrder.set(prop.name, this.props.length);
        /* istanbul ignore next */
        if (sync) {
            this.sync();
        }
    }
    removeProperty(name, sync = true) {
        delete this.properties[name];
        this.propertyOrder.delete(name);
        /* istanbul ignore next */
        if (sync) {
            this.sync();
        }
    }
    getPrimaryProps() {
        return this.primaryKeys.map(pk => this.properties[pk]);
    }
    get tableName() {
        return this.collection;
    }
    set tableName(name) {
        this.collection = name;
    }
    sync(initIndexes = false) {
        this.root ?? (this.root = this);
        const props = Object.values(this.properties).sort((a, b) => this.propertyOrder.get(a.name) - this.propertyOrder.get(b.name));
        this.props = [...props.filter(p => p.primary), ...props.filter(p => !p.primary)];
        this.relations = this.props.filter(prop => prop.reference !== enums_1.ReferenceType.SCALAR && prop.reference !== enums_1.ReferenceType.EMBEDDED);
        this.bidirectionalRelations = this.relations.filter(prop => prop.mappedBy || prop.inversedBy);
        this.uniqueProps = this.props.filter(prop => prop.unique);
        this.comparableProps = this.props.filter(prop => EntityComparator_1.EntityComparator.isComparable(prop, this.root));
        this.hydrateProps = this.props.filter(prop => {
            // `prop.userDefined` is either `undefined` or `false`
            const discriminator = this.root.discriminatorColumn === prop.name && prop.userDefined === false;
            // even if we dont have a setter, do not ignore value from database!
            const onlyGetter = prop.getter && !prop.setter && prop.persist === false;
            return !prop.inherited && !discriminator && !prop.embedded && !onlyGetter;
        });
        this.selfReferencing = this.relations.some(prop => [this.className, this.root.className].includes(prop.type));
        if (initIndexes && this.name) {
            this.props.forEach(prop => this.initIndexes(prop));
        }
        this.definedProperties = this.props.reduce((o, prop) => {
            const isCollection = [enums_1.ReferenceType.ONE_TO_MANY, enums_1.ReferenceType.MANY_TO_MANY].includes(prop.reference);
            const isReference = [enums_1.ReferenceType.ONE_TO_ONE, enums_1.ReferenceType.MANY_TO_ONE].includes(prop.reference) && (prop.inversedBy || prop.mappedBy) && !prop.mapToPk;
            if (prop.inherited || prop.primary || isCollection || prop.persist === false || isReference || prop.embedded) {
                return o;
            }
            o[prop.name] = {
                get() {
                    return this.__helper.__data[prop.name];
                },
                set(val) {
                    this.__helper.__data[prop.name] = val;
                    this.__helper.__touched = true;
                },
                enumerable: true,
                configurable: true,
            };
            return o;
        }, { __gettersDefined: { value: true, enumerable: false } });
    }
    initIndexes(prop) {
        const simpleIndex = this.indexes.find(index => index.properties === prop.name && !index.options && !index.type && !index.expression);
        const simpleUnique = this.uniques.find(index => index.properties === prop.name && !index.options);
        const owner = prop.reference === enums_1.ReferenceType.MANY_TO_ONE || (prop.reference === enums_1.ReferenceType.ONE_TO_ONE && prop.owner);
        if (!prop.index && simpleIndex) {
            Utils_1.Utils.defaultValue(simpleIndex, 'name', true);
            prop.index = simpleIndex.name;
            this.indexes.splice(this.indexes.indexOf(simpleIndex), 1);
        }
        if (!prop.unique && simpleUnique) {
            Utils_1.Utils.defaultValue(simpleUnique, 'name', true);
            prop.unique = simpleUnique.name;
            this.uniques.splice(this.uniques.indexOf(simpleUnique), 1);
        }
        if (owner && prop.fieldNames.length > 1) {
            this.indexes.push({ properties: prop.name });
            prop.index = false;
        }
        if (owner && prop.fieldNames.length > 1 && prop.unique) {
            this.uniques.push({ properties: prop.name });
            prop.unique = false;
        }
    }
}
exports.EntityMetadata = EntityMetadata;
