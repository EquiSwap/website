import { ExportFromClause } from './ast/module/export-from-clause';
import { PropertyName } from './ast/expressions/property-name';
import { ImportCall } from './ast/expressions/import-call';
import { TemplateLiteral } from './ast/expressions/template-literal';
import { TemplateElement } from './ast/expressions/template-element';
import { TemplateExpression } from './ast/expressions/template-expression';
import { AwaitExpression } from './ast/expressions/await-expr';
import { ImportExport } from './ast/module/index';
import { AssignmentExpression } from './ast/expressions/assignment-expr';
import { ExportDeclaration } from './ast/module/export-declaration';
import { ExportSpecifier } from './ast/module/export-specifier';
import { ExportDefault } from './ast/module/export-default';
import { ImportSpecifier } from './ast/module/import-specifier';
import { NamedImports } from './ast/module/named-imports';
import { ImportClause } from './ast/module/import-clause';
import { ImportDeclaration } from './ast/module/import-declaration';
import { WhileStatement } from './ast/statements/while-stmt';
import { DoWhileStatement } from './ast/statements/do-stmt';
import { IfStatement } from './ast/statements/if-stmt';
import { CommaOperator } from './ast/expressions/commaOperator';
import { Statement, CaseBlock } from './ast/statements/index';
import { RegularExpressionLiteral } from './ast/expressions/regular-expression';
import { YieldExpression } from './ast/expressions/yield-expr';
import { NewTarget } from './ast/expressions/new-target';
import { AssignmentElement } from './ast/expressions/assignment-element';
import { MemberExpression } from './ast/expressions/member-expr';
import { IdentifierReference } from './ast/expressions/identifierreference';
import { OptionalExpression } from './ast/expressions/optional-expr';
import { AssignmentRestElement } from './ast/expressions/assignment-rest-element';
import { ObjectBindingPattern } from './ast/expressions/object-binding-pattern';
import { FunctionExpression } from './ast/expressions/function-expr';
import { FunctionDeclaration } from './ast/declarations/function-declaration';
import { BindingElement } from './ast/expressions/binding-element';
import { ArrayBindingPattern } from './ast/expressions/array-binding-pattern';
import { ClassElement } from './ast/expressions/class-element';
import { ClassExpression } from './ast/expressions/class-expr';
import { ClassDeclaration } from './ast/declarations/class-declaration';
import { ForOfStatement } from './ast/statements/for-of-stmt';
import { ForInStatement } from './ast/statements/for-in-stmt';
import { ForStatement } from './ast/statements/for-stmt';
import { ParenthesizedExpression } from './ast/expressions/parenthesized-expr';
import { ArrayLiteral } from './ast/expressions/array-literal';
import { BindingRestElement } from './ast/expressions/binding-rest-element';
import { SuperCall } from './ast/expressions/super-call';
import { SuperProperty } from './ast/expressions/super-property';
import { SpreadElement } from './ast/expressions/spread-element';
import { SpreadProperty } from './ast/expressions/spread-property';
import { ArrowFunction, ArrowFormals } from './ast/expressions/arrow-function';
import { MethodDefinition } from './ast/expressions/method-definition';
import { FunctionBody } from './ast/expressions/function-body';
import { ObjectLiteral } from './ast/expressions/object-literal';
import { MemberChain } from './ast/expressions/member-chain-expr';
import { ThisExpression } from './ast/expressions/this-expr';
import { NullLiteral } from './ast/expressions/null-literal';
import { StringLiteral } from './ast/expressions/string-literal';
import { NumericLiteral } from './ast/expressions/numeric-literal';
import { BooleanLiteral } from './ast/expressions/boolean-literal';
import { CallChain } from './ast/expressions/call-chain';
import { NewExpression } from './ast/expressions/new-expr';
import { IdentifierName } from './ast/expressions/identifiername';
import { BindingIdentifier } from './ast/expressions/binding-identifier';
import { BindingRestProperty } from './ast/expressions/binding-rest-property';
import { ExpressionStatement } from './ast/statements/expression-stmt';
import { UnaryExpression } from './ast/expressions/unary-expr';
import { PrefixUpdateExpression } from './ast/expressions/prefix-update-expr';
import { PostfixUpdateExpression } from './ast/expressions/postfix-update-expr';
import { BlockStatement } from './ast/statements/block-stmt';
import { EmptyStatement } from './ast/statements/empty-stmt';
import { DebuggerStatement } from './ast/statements/debugger-stmt';
import { ReturnStatement } from './ast/statements/return-stmt';
import { BreakStatement } from './ast/statements/break-stmt';
import { ContinueStatement } from './ast/statements/continue-stmt';
import { LabelledStatement } from './ast/statements/labelled-stmt';
import { WithStatement } from './ast/statements/with-stmt';
import { ThrowStatement } from './ast/statements/throw-stmt';
import { CatchClause, TryStatement } from './ast/statements/try-stmt';
import { ConditionalExpression } from './ast/expressions/conditional-expr';
import { BinaryExpression } from './ast/expressions/binary-expr';
import { LexicalBinding } from './ast/statements/lexical-binding';
import { LexicalDeclaration } from './ast/declarations/lexical-declaration';
import { VariableStatement } from './ast/statements/variable-stmt';
import { VariableDeclaration } from './ast/declarations/variable-declaration';
import { SwitchStatement } from './ast/statements/switch-stmt';
import { Token } from './ast/token';
import { Constants } from './constants';
import { Expression, MethodName, Parameter, BindingPattern, LeftHandSideExpression } from './ast/expressions/index';
import { ScopeState } from './scope';
import { Context, BindingType, ParserState, Destructible, PropertyKind, ArrowKind, DestuctionKind } from './common';
export interface StatementCallback {
    (state: ParserState, context: Context, scope: ScopeState, label: any, labelSet: any): Statement;
}
export interface LexicalCallback {
    (state: ParserState, context: Context, scope: ScopeState, type: BindingType): LexicalBinding | VariableDeclaration;
}
export declare function create(source: string, nodeCursor?: any): ParserState;
export declare function parseModuleItemList(state: ParserState, context: Context, scope: ScopeState, statementList: Statement[]): Statement[];
export declare function parseStatementList(state: ParserState, context: Context, scope: ScopeState, statementList: Statement[]): Statement[];
export declare function parseStatemenOrModuleItemtList(state: ParserState, context: Context, scope: ScopeState, statementList: Statement[], cb: StatementCallback): Statement[];
export declare function parseStatementListItem(state: ParserState, context: Context, scope: ScopeState, labels: any, ownLabels: any[] | null): Statement;
export declare function parseStatement(state: ParserState, context: Context, scope: ScopeState, labels: any[], ownLabels: any[] | null, allowFunction: boolean): Statement;
export declare function parseModuleItem(state: ParserState, context: Context, scope: ScopeState): ImportExport;
export declare function parseImportDeclaration(state: ParserState, context: Context, scope: ScopeState, start: number): ImportDeclaration | ExpressionStatement;
export declare function parseImportClause(state: ParserState, context: Context, scope: ScopeState): ImportClause;
export declare function parseNameSpaceImport(state: ParserState, context: Context, scope: ScopeState): BindingIdentifier;
export declare function parseNamedImports(state: ParserState, context: Context, scope: ScopeState): NamedImports;
export declare function parseImportSpecifier(state: ParserState, context: Context, scope: ScopeState): ImportSpecifier;
export declare function parseSwitchStatement(state: ParserState, context: Context, scope: ScopeState, labels: any[], ownLabels: any[] | null): SwitchStatement;
export declare function parseCaseBlock(state: ParserState, context: Context, scope: ScopeState, labels: any[], ownLabels: any[] | null): CaseBlock[];
export declare function parseCaseOrDefaultClause(state: ParserState, context: Context, scope: ScopeState, check: Constants, labels: any[], ownLabels: any[] | null): CaseBlock;
export declare function parseWithStatement(state: ParserState, context: Context, scope: ScopeState, labels: any[], ownLabels: any[] | null): WithStatement;
export declare function parseThrowStatement(state: ParserState, context: Context): ThrowStatement;
export declare function parseTryStatement(state: ParserState, context: Context, scope: any, labels: any[]): TryStatement;
export declare function parseCatchClause(state: ParserState, context: Context, scope: ScopeState, labels: any[]): CatchClause;
export declare function parseIfStatement(state: ParserState, context: Context, scope: ScopeState, labels: any[]): IfStatement;
export declare function parseConsequentOrAlternative(state: ParserState, context: Context, scope: ScopeState, labels: any[]): Statement;
export declare function parseWhileStatement(state: ParserState, context: Context, scope: ScopeState, labels: any[], ownLabels: any[] | null): WhileStatement;
export declare function parseDoWhileStatement(state: ParserState, context: Context, scope: ScopeState, labels: any[], nestedLabel: any): DoWhileStatement;
export declare function parseBlockStatement(state: ParserState, context: Context, scope: ScopeState, isCatchScope: boolean, labels: any[], ownLabels: any[] | null): BlockStatement;
export declare function parseDebuggerStatement(state: ParserState, context: Context): DebuggerStatement;
export declare function parseBreakStatement(state: ParserState, context: Context, labels: any[]): BreakStatement;
export declare function parseContinueStatement(state: ParserState, context: Context, labels: any[]): ContinueStatement;
export declare function parseEmptyStatement(state: ParserState, context: Context): EmptyStatement;
export declare function parseReturnStatement(state: ParserState, context: Context): ReturnStatement;
export declare function parseForStatement(state: ParserState, context: Context, scope: ScopeState, labels: any[]): ForStatement | ForOfStatement | ForInStatement;
export declare function parseBindingOrVariableDeclarationList(state: ParserState, context: Context, scope: any, type: BindingType, cb: LexicalCallback): (LexicalBinding | VariableDeclaration)[];
export declare function parseForLexicalBinding(state: ParserState, context: Context, scope: any, type: BindingType): LexicalBinding;
export declare function parseForVariableDeclaration(state: ParserState, context: Context, scope: any, type: BindingType): VariableDeclaration;
export declare function parseExpressionOrLabelledStatement(state: ParserState, context: Context, scope: ScopeState, labels: any[], ownLabels: any[] | null, allowFunction: boolean): LabelledStatement | ExpressionStatement;
export declare function parseLabelledStatement(state: ParserState, context: Context, scope: any, token: Token, value: string, labels: any[], ownLabels: any[] | null, allowFunction: boolean, start: number): ExpressionStatement;
export declare function parseExpressionStatement(state: ParserState, context: Context, expression: Expression, start: number): ExpressionStatement;
export declare function parseExpression(state: ParserState, context: Context): Expression;
export declare function parseExpressions(state: ParserState, context: Context): Expression;
export declare function parseCommaOperator(state: ParserState, context: Context, expression: Expression, start: number): CommaOperator | Expression;
export declare function parseIdentifierReference(state: ParserState, context: Context): IdentifierReference;
export declare function parseIdentifierName(state: ParserState, context: Context): IdentifierName;
export declare function parseBindingIdentifier(state: ParserState, context: Context, scope: any, type: BindingType): BindingIdentifier;
export declare function parseVariableStatement(state: ParserState, context: Context, scope: ScopeState, type: BindingType): VariableStatement;
export declare function parseVariableDeclaration(state: ParserState, context: Context, scope: any, type: BindingType): VariableDeclaration;
export declare function parseVariableDeclarationList(state: ParserState, context: Context, scope: ScopeState, type: BindingType): VariableDeclaration[];
export declare function parseLexicalDeclaration(state: ParserState, context: Context, scope: ScopeState, type: BindingType, labels: any[], ownLabels: any[] | null): LexicalDeclaration | Statement;
export declare function parseLetAsIdentifierReference(state: ParserState, context: Context, start: number, labels: any[], ownLabels: any[] | null): Statement;
export declare function parseAsyncAsIdentifierReference(state: ParserState, context: Context, scope: any): Statement;
export declare function parseLexicalBinding(state: ParserState, context: Context, scope: any, type: BindingType): LexicalBinding;
export declare function parseBindingList(state: ParserState, context: Context, scope: any, type: BindingType): (LexicalBinding | VariableDeclaration)[];
export declare function parseAssignmentExpression(state: ParserState, context: Context, left: Expression, start: number): AssignmentExpression | Expression;
export declare function parseConditionalExpression(state: ParserState, context: Context, left: Expression, start: number): Expression | ConditionalExpression;
export declare function parseBinaryExpression(state: ParserState, context: Context, left: BinaryExpression | Expression, minPrec: number, start: number): BinaryExpression | Expression;
export declare function parseLeftHandSideExpression(state: ParserState, context: Context, assignable: boolean): Expression;
export declare function parseMemberExpression(state: ParserState, context: Context, member: Expression, allowCalls: boolean, start: number): MemberExpression | OptionalExpression | PostfixUpdateExpression | Expression;
export declare function parsePropertyOrPrivatePropertyName(state: ParserState, context: Context): IdentifierName | IdentifierReference;
export declare function parseOptionalChain(state: ParserState, context: Context): CallChain | MemberChain;
export declare function parseMemberChain(state: ParserState, context: Context, chain: MemberChain | CallChain | null, expr: Expression, computed: boolean, start: number): MemberChain;
export declare function parseCallChain(state: ParserState, context: Context, chain: MemberChain | CallChain | null, expr: Expression[], start: number): CallChain;
export declare function parseArguments(state: ParserState, context: Context): (Expression | AssignmentRestElement)[];
export declare function parseArgumentList(state: ParserState, context: Context): Expression | AssignmentRestElement;
export declare function parseUnaryExpression(state: ParserState, context: Context): UnaryExpression;
export declare function parsePostfixUpdateExpression(state: ParserState, context: Context, operand: Expression): PostfixUpdateExpression | Expression;
export declare function parsePrefixUpdateExpression(state: ParserState, context: Context): PrefixUpdateExpression;
export declare function parseAwaitExpression(state: ParserState, context: Context): AwaitExpression;
export declare function parseYieldExpression(state: ParserState, context: Context): YieldExpression;
export declare function parsePrimaryExpression(state: ParserState, context: Context, assignable: boolean): LeftHandSideExpression;
export declare function parseImportMetaOrCall(state: ParserState, context: Context): ImportCall | ImportMeta;
export declare function parseNewExpression(state: ParserState, context: Context): NewExpression | NewTarget;
export declare function parseBooleanLiteral(state: ParserState, context: Context): BooleanLiteral;
export declare function parseNumericLiteral(state: ParserState, context: Context): NumericLiteral;
export declare function parseFloatingPointLiteral(state: ParserState, context: Context): NumericLiteral;
export declare function parseBigIntLiteral(state: ParserState, context: Context): NumericLiteral;
export declare function parseTemplateLiteral(state: ParserState, context: Context): TemplateLiteral;
export declare function parseStringLiteral(state: ParserState, context: Context, isDirective: boolean): StringLiteral;
export declare function parseNullLiteral(state: ParserState, context: Context): NullLiteral;
export declare function parseThisExpression(state: ParserState, context: Context): ThisExpression;
export declare function parseRegularExpressionLiteral(state: ParserState, context: Context): RegularExpressionLiteral;
export declare function parseTemplateExpression(state: ParserState, context: Context): TemplateExpression;
export declare function parseTemplateElementContinuation(state: ParserState, context: Context): TemplateElement;
export declare function parseTemplateElement(state: ParserState, context: Context): TemplateElement;
export declare function parseObjectBindingPattern(state: ParserState, context: Context, scope: ScopeState, type: BindingType): ObjectBindingPattern;
export declare function parseBindingRestProperty(state: ParserState, context: Context, type: BindingType): BindingRestProperty;
export declare function parseBindingProperty(state: ParserState, context: Context, scope: ScopeState, type: BindingType): PropertyName | BindingIdentifier;
export declare function parseBindingElement(state: ParserState, context: Context, scope: any, type: BindingType): BindingElement | BindingIdentifier | BindingPattern;
export declare function parseBindingPattern(state: ParserState, context: Context, scope: any, type: BindingType): BindingPattern;
export declare function parseBindingPatternOrIdentifier(state: ParserState, context: Context, scope: any, type: BindingType): BindingPattern | BindingIdentifier;
export declare function parseArrayBindingPattern(state: ParserState, context: Context, scope: any, type: BindingType): ArrayBindingPattern;
export declare function parseBindingRestElement(state: ParserState, context: Context, scope: any, type: BindingType): BindingRestElement;
export declare function parseArrayLiteral(state: ParserState, context: Context, scope: any, isRest: DestuctionKind, type: BindingType): ArrayLiteral | AssignmentElement;
export declare function parseElementList(state: ParserState, context: Context, scope: any, type: BindingType): SpreadElement | Expression | AssignmentExpression;
export declare function parseSpreadElement(state: ParserState, context: Context, scope: any, type: BindingType, start: number): SpreadElement;
export declare function parseSpreadProperty(state: ParserState, context: Context, scope: any, type: BindingType, start: number): SpreadProperty;
export declare function parseAssignmentRestElement(state: ParserState, context: Context, scope: any, type: BindingType, start: number): AssignmentRestElement;
export declare function parseSpreadOrPropertyArgument(state: ParserState, context: Context, closingToken: Token, isSpread: boolean, scope: any, type: BindingType, start: number): Expression;
export declare function parseObjectLiteral(state: ParserState, context: Context, scope: ScopeState | void, isRest: DestuctionKind, type: BindingType): ObjectLiteral | AssignmentElement;
export declare function parseAssignmentElement(state: ParserState, context: Context, destructible: Destructible, left: ArrayLiteral | ObjectLiteral, kind: DestuctionKind, start: number): AssignmentElement;
export declare function parsePropertyDefinition(state: ParserState, context: Context, scope: any, type: BindingType): SpreadProperty | MethodDefinition;
export declare function parsePropertyName(state: ParserState, context: Context): any;
export declare function parseFormalParameters(state: ParserState, context: Context, scope: any): Parameter[];
export declare function parseUniqueFormalParameters(state: ParserState, context: Context, scope: any): Parameter[];
export declare function parseFunctionBody(state: ParserState, context: Context, scope: any, firstRestricted: Token | undefined, isStatement: boolean): FunctionBody;
export declare function parseMethodDefinition(state: ParserState, context: Context, key: MethodName, kind: PropertyKind): MethodDefinition;
export declare function parseFunctionExpression(state: ParserState, context: Context, assignable: boolean): FunctionExpression | IdentifierReference | Expression;
export declare function parseAsyncArrowExpression(state: ParserState, context: Context, assignable: boolean, start: number): Expression;
export declare function parseFunctionDeclaration(state: ParserState, context: Context, scope: ScopeState, disallowGen: boolean, isHoisted?: boolean): FunctionDeclaration | ExpressionStatement | ArrowFunction;
export declare function parseAsyncArrowDeclaration(state: ParserState, context: Context, start: number): any;
export declare function parseArrowAfterIdentifier(state: ParserState, context: Context, params: BindingIdentifier, value: string, assignable: boolean, kind: ArrowKind, start: number): ArrowFunction;
export declare function parseCoverCallExpressionAndAsyncArrowHead(state: ParserState, context: Context, expr: Expression, hasLineTerminator: boolean, assignable: boolean, start: number): ArrowFunction | Expression;
export declare function parseArrowFunction(state: ParserState, context: Context, scope: any, arrowParameters: boolean, parameters: any, isAsync: ArrowKind, start: number): ArrowFunction;
export declare function parseConciseOrFunctionBody(state: ParserState, context: Context, scope: any): FunctionBody | Expression;
export declare function parseCoverParenthesizedExpressionAndArrowParameterList(state: ParserState, context: Context, assignable: boolean): Expression | ArrowFunction | ParenthesizedExpression;
export declare function parseArrowAfterParen(state: ParserState, context: Context, scope: ScopeState, assignable: boolean, destructible: Destructible, kind: ArrowKind, params: ArrowFormals[], start: number): Expression | ArrowFunction | ParenthesizedExpression;
export declare function parseClassDeclaration(state: ParserState, context: Context, scope: any, isHoisted?: boolean): ClassDeclaration;
export declare function parseClassExpression(state: ParserState, context: Context): ClassExpression;
export declare function parseClassElementList(state: ParserState, context: Context, inheritedContext: Context): ClassElement[];
export declare function parseClassElement(state: ParserState, context: Context, inheritedContext: Context, isStatic: boolean, kind: PropertyKind): ClassElement;
export declare function parseSuperCallOrProperty(state: ParserState, context: Context): SuperCall | SuperProperty;
export declare function parseExpressionOrHigher(state: ParserState, context: Context, expr: Expression | CommaOperator | IdentifierReference | ArrowFunction, start: number): Expression;
export declare function parseImportCall(state: ParserState, context: Context, start: number): ExpressionStatement;
export declare function parseImportMeta(state: ParserState, context: Context, start: number): ExpressionStatement;
export declare function parseModuleExportName(state: ParserState, context: Context): StringLiteral;
export declare function parseFromClause(state: ParserState, context: Context): StringLiteral;
export declare function parseExportDeclaration(state: ParserState, context: Context, scope: ScopeState): ExportDeclaration | ExportDefault;
export declare function parseExportFromClause(state: ParserState, context: Context, start: number): ExportFromClause;
export declare function parseNamedExports(state: ParserState, context: Context, exportedNames: string[], exportedBindings: string[]): ExportSpecifier[];
export declare function parseExportSpecifier(state: ParserState, context: Context, exportedNames: string[], exportedBindings: string[]): ExportSpecifier;
export declare function parseExportDefault(state: ParserState, context: Context, start: number, scope: any): ExportDefault;
//# sourceMappingURL=parser.d.ts.map